# 你不懂JS：作用域和闭包

#第二章：词法作用域

在第一章中，我们将“作用域”定义为一组规定了引擎如何通过变量名查找变量的规则，变量要么在当前作用域中，要么在包含它的嵌套作用域中。

对于作用域是如何工作的，有两种主要的模型来描述。第一种最为大众所熟知，也被绝大多数编程语言所采用，称为**词法作用域**，我们接下来会深入探讨。另一种模型，仍然有一些语言（例如Bash脚本、Perl中的部分模块，等等）在采用，称为**动态作用域**。

动态作用域会在附录A中讲解。我们在此提到它仅仅是为了和词法作用域做一个对比，也就是JavaScript使用的作用域模型。

# 词法分析时间到

如我们在第一章所讨论的那样，一个标准语言编译器的第一个步骤被称为词法分析（也就是分词）。如果你还记得的话，词法分析过程会检查源代码字符组成的字符串，并将一些语义赋给token作为有状态的解析的结果。

正是这一概念提供了什么是词法作用域以及这个名字来自何处这个问题的基础。

我们要再定义一次的话，词法作用域是在词法分析阶段被定义的作用域。换句话说，词法作用域是以变量和代码块被（你）编写的时候的作用域为基础的，因此（大部分）都在词法分析器处理你的代码的时候被固定下来了。

**注：**我们之后会看到一些欺骗词法作用域的方式，从而在词法分析器经过之后仍能修改它，但这种方式将会被抛弃。我们认为最佳对待词法作用域的方式就是完全使它词法化，这样我们就很自然的只会在编写代码的阶段考虑到它了。

让我们考虑一下下面这一块代码：

	function foo(a) {

    var b = a * 2;

    function bar(c) {
        console.log( a, b, c );
    }

    bar(b * 3);
	}
	
	foo( 2 ); // 2, 4, 12

这段示例代码中有三个嵌套作用域。将这些作用域想象成一个装在另一个的气泡能有助于你的理解。

<img src="fig2.png" width="500">

气泡1围绕的部分是全局作用域，它只有一个标识符：`foo`。

气泡2围绕的部分是`foo`的作用域，它包含三个标识符：`a`，`bar`和`b`。

气泡3围绕的部分是`bar`的作用域，它仅仅包含一个标识符：`c`。

作用域气泡是根据作用域代码块被编写的所在地来定义的，每个都是内嵌在另一个的内部，等等。在下一章，我们会讨论作用域的其他单元，但是现在，我们仅仅假设每一个函数都创建了一个新的作用域气泡。

`bar`的气泡整体被包含在`foo`的气泡中，因为（也仅因为）这里就是我们定义函数`bar`的地方。

注意这些内嵌的气泡都是严格内嵌的。我们并不是讨论维恩图那种气泡可以穿过其他气泡边界的情况。换句话说，没有一个函数的气泡可以同时（部分）存在于两个外部的气泡中，因为没有函数可以部分处在两个父函数的内部。

## 查找

这些作用域气泡的结构以及相对的位置关系完全地向引擎解释了它查找一个标识符时需要的所有位置。

在上面的代码片段中，引擎执行`console.log(..)`语句并去查找三个被引用的变量`a`，`b`和`c`。它首先从最内部的作用域气泡查找，也就是`bar(..)`函数的作用域。它在那里找不到`a`，因此它往上一层，到达距离次近的作用域气泡，也就是函数`foo(..)`的作用域。然后它找到了`a`，于是就是用这个`a`。对于`b`也是同样。而对于`c`，它会在`bar(..)`的内部被找到。

如果同时有一个`c`在`bar(..)`的内部和`foo(..)`的内部，那么`console.log(..)`语句会找到并使用`bar(..)`内部的那个，而永远不会获得`foo(..)`中的。

**作用域一旦发现第一个匹配的结果时就停止查找。**同名的标识符可以在内嵌作用域的多个层被定义，这被称为“投影”（内部的标识符“投影”到外部的标识符）。无论有没有投影，作用域查找总是从当前正在被执行的最内部的作用域开始，然后沿着向外/向上的方向直到找到第一个匹配，然后停止。

**注：**全局变量同时自动的成为全局对象（在浏览器中是`window`）的属性，因此引用一个全局对象可以不直接通过它的词法名称，而可以间接地以全局对象的属性的方式引用。

	windows.a
	
这一技术使得我们可以访问因为投影而无法被直接访问到的全局变量。但是，非全局的被投影的变量则无法被访问到。

无论一个函数从哪里被调用，或如何被调用，它的词法作用域**仅仅**被函数所声明的地方定义。

词法作用域查找的过程只适用于主标识符，例如`a`，`b`和`c`。如果你在代码中有一个对`foo.bar.baz`的引用，词法作用域的查找只会去找到`foo`标识符，一旦它定义了这个变量，对象属性访问规则则会继续接管去分别处理`bar`和`baz`属性。

# 欺骗词法分析器

如果作用域完全只通过函数声明的地方被定义，它就是完全的编写时决定的，既然如此我们怎么才能在运行时“修改”（欺骗）词法作用域呢？

JavaScript有两种机制可以实现这个功能。它们都在更外部的社区中被认为是错误的实现而不建议在你的代码中使用。但是这种反对其实往往错过了最重要的一点：**欺骗词法作用域会导致性能降低。**

在我解释性能问题之前，我们先来看看这两种机制是如何运作的。

## `eval`

JavaScript中的`eval(..)`函数接受一个字符串作为参数，并将其内容视为在程序当前时刻被编写的代码。换句话说，你可以通过编程的方式在你编写的代码内部生成代码，并执行该生成的代码就像它在编写程序时就已经在那里了一样。

在阳光下评估一下`eval(..)`，我们应该明白`eval(..)`是如何允许你通过欺骗、假装自己是编写代码时刻的代码（即词法时代码）的方式修改词法作用域环境的。

在`eval`代码执行后的代码行中，引擎不会“知晓”或“关心”之前的代码是否是动态解释的，也不管是否因此而修改了词法作用域环境。引擎只会像平常一样简单的执行词法作用域查询。

考虑一下下面的代码：

	function foo(str, a) {
	    eval( str ); // cheating!
	    console.log( a, b );
	}

	var b = 2;

	foo( "var b = 3;", 1 ); // 1, 3
	
这里，在`eval(..)`函数调用时的字符串`"var b = 3;"`被当做一直处在该处。因为这段代码刚刚申明了一个新变量`b`，它会修改当前`foo(..)`的词法作用域。事实上，如我们上文提到的那样，这段代码实际上在`foo(..)`的内部创建了变量`b`从而投影了在外部（全局）作用域上所定义的`b`。

当`console.log(..)`调用发生时，它会在`foo(..)`的作用域内同时发现`a`和`b`，而永远不会发现外部的`b`。因此它会输出"1, 3"而不是一般情况下的"1, 2"。

**注：**在本例中，为了简单起见，"代码"字符串是一串固定的文字。而它也很容易通过基于程序的逻辑添加特征量来程序化的创建。`eval(..)`通常用来执行动态创建的代码，因为从字符串中动态生成本来就是静态的代码和直接编写代码比起来不会有任何实际的好处。

如果`eval(..)`执行的一段字符串中包含一个或者多个声明（无论是变量还是函数），默认情况下这种行为会修改`eval(..)`所在的词法作用域。从技术的角度来说，`eval(..)`可以通过一些技巧被“间接地”调用（我们这里不做讨论），而会导致它在全局作用域中执行，从而达到修改它的目的。但是无论怎样，`eval(..)`都能在执行时修改我们当初编写时的词法作用域。

**注：**当`eval(..)`被用在严格模式下的程序时，它只能操作自己的词法作用域，这表示在`eval(..)`内部声明的变量实际上并不会修改围绕它的作用域。

	function foo(str) {
	   "use strict";
	   eval( str );
	   console.log( a ); // ReferenceError: a is not defined
	}

	foo( "var a = 2" );
	
JavaScript中有一些其他的函数有着和`eval(..)`非常类似的功能。例如`setTimeout(..)`和`setInterval(..)`可以接受一个字符串作为它们的第一个参数，其内容会被`eval`化成为动态生成的函数。这已经非常古老了，这些行为已经被弃用，不要这样使用！

`new Function(..)`函数会类似地在**最后一个**参数中接受字符串代码并将其转化为一个动态生成的函数（如果有第一个参数的话它会成为新函数的名字）。这种构造函数风格比`eval(..)`要稍微安全一点点，但你仍然应该在你的代码中避免使用。

需要在你的程序中使用动态生成代码的场景是十分罕见的，它所导致的性能问题要远远大于它的能力。

## `with`

JavaScript中另外一个令人讨厌（并且现在已经废弃）的用来欺骗词法作用域的方法是`with`关键词。`with`可以被解释成不同的能力，我这里选择性的向各位介绍它是如何继承和改变词法作用域的。

`with`一般来说是用来简单地构造对象的多个属性引用而不需要每次重复这个对象引用。

例如：

	var obj = {
	    a: 1,
	    b: 2,
	    c: 3
	};
	
	// more "tedious" to repeat "obj"
	obj.a = 2;
	obj.b = 3;
	obj.c = 4;
	
	// "easier" short-hand
	with (obj) {
	    a = 3;
	    b = 4;
	    c = 5;
	}

但是，除了简化访问对象属性之外还有许多别的用法，例如：

	function foo(obj) {
	    with (obj) {
	        a = 2;
	    }
	}
	
	var o1 = {
	    a: 3
	};
	
	var o2 = {
	    b: 3
	};
	
	foo( o1 );
	console.log( o1.a ); // 2
	
	foo( o2 );
	console.log( o2.a ); // undefined
	console.log( a ); // 2 -- Oops, leaked global!

在上面的例子里，我们创建了两个对象`o1`和`o2`。一个包含`a`属性，另一个没有。`foo(..)`函数会获取参数`obj`的引用，并在它之上调用`with(obj){ .. }`。在`with`块的内部，我们可以像平常一样引用变量`a`，实际上这是一种LHS引用（见第一章），将值`2`赋予给它。

当我们将其传递给`o1`时，`a = 2`赋值语句会找到`o1.a`属性，并将值`2`赋予给它，然后会在下面的`console.log(o1.a)`语句反映出来。但是，当我们把`o2`传递进去时，因为`o2`没有一个`a`属性。因此不会有这样的属性被赋值，所以`o2.a`还是`undefined`。

然后我们就注意到了这里的一个副作用，一个全局变量`a`被`a = 2`语句创建了。怎么会这样呢？

这个`with`语句会获取一个对象，这个对象有0个或多个属性，并将该对象视为**一个完全单独的词法作用域**，因此对象的属性被认为是在那个“作用域”中通过词法定义的。

**注：**即使一个`with`块将一个对象视为一个词法作用域，`with`块内部的普通的`var`声明不会以`with`块作为作用域，而实际上会以包含它的函数作为作用域。

`eval(..)`函数可以通过接收一段包含了一个或多个声明的代码字符串修改当前存在的词法作用域，而`with`语句实际上是从你传递的对象上凭空创建了一个**完全新的词法作用域**。

可以这样理解：我们传递`o1`，通过`with`语句所声明的“作用域”实际就是`o1`。这个“作用域”上有一个“标识符”代表着`o1.a`属性。但是当我们将`o2`视为“作用域”时，它内部并没有这样的`a`标识符，因此LHS查询（见第一章）的基本规则就发生了。

由于在“作用域”`o2`、作用域`foo(..)`以及全局作用域中都没有这样一个`a`标识符，因此当`a = 2`执行时，它会导致全局变量被自动创建（因为这里不是严格模式）。

思考`with`语句是如何将一个对象以及他的属性转变为一个带有“标识符”的“作用域”是有点费解的。这是我能够说明的最清晰的方式了。

**注：**使用这两种方式是个糟糕的主意，不仅如此，`eval(..)`和`with`都受到严格模式的影响（限制）。`with`是完全不允许使用的，而各种间接的或不安全的`eval(..)`也不被允许，只保留了其核心功能。

## 性能

`eval(..)`和`with`都可以通过在运行时修改或创建新词法作用域的方式欺骗我们在编写时所定义的词法作用域。

所以你可能会问：这怎么了吗？如果他们可以提供更巧妙的函数以及代码编写的便利性，它们不就是很棒的特性吗？**并不是。**

JavaScript引擎在编译阶段会采用非常多的性能优化手段。这些都归功于这些代码可以被静态地作为词法进行分析，并可以预定义所有的变量与函数声明的地点，因此在执行时引擎就能花费较少的努力来获取这些标识符。

而当引擎在代码中遇到一个`eval(..)`或`with`时。它基本上必须假定它所有已知的标识符位置都可能是无效的，因为它不能在词法分析的时刻知道那些代码可能会被传递到`eval(..)`中以修改词法作用域，也不可能知道你传递给`with`来创建一个新的词法作用域的是哪一个对象。

换句话说，在