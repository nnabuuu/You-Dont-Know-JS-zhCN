# 你不懂JS：作用域和闭包

#第二章：词法作用域

在第一章中，我们将“作用域”定义为一组规定了引擎如何通过变量名查找变量的规则，变量要么在当前作用域中，要么在包含它的嵌套作用域中。

对于作用域是如何工作的，有两种主要的模型来描述。第一种最为大众所熟知，也被绝大多数编程语言所采用，称为**词法作用域**，我们接下来会深入探讨。另一种模型，仍然有一些语言（例如Bash脚本、Perl中的部分模块，等等）在采用，称为**动态作用域**。

动态作用域会在附录A中讲解。我们在此提到它仅仅是为了和词法作用域做一个对比，也就是JavaScript使用的作用域模型。

# 词法分析时间到

如我们在第一章所讨论的那样，一个标准语言编译器的第一个步骤被称为词法分析（也就是分词）。如果你还记得的话，词法分析过程会检查源代码字符组成的字符串，并将一些语义赋给token作为有状态的解析的结果。

正是这一概念提供了什么是词法作用域以及这个名字来自何处这个问题的基础。

我们要再定义一次的话，词法作用域是在词法分析阶段被定义的作用域。换句话说，词法作用域是以变量和代码块被（你）编写的时候的作用域为基础的，因此（大部分）都在词法分析器处理你的代码的时候被固定下来了。

**注：**我们之后会看到一些欺骗词法作用域的方式，从而在词法分析器经过之后仍能修改它，但这种方式将会被抛弃。我们认为最佳对待词法作用域的方式就是完全使它词法化，这样我们就很自然的只会在编写代码的阶段考虑到它了。

让我们考虑一下下面这一块代码：

	function foo(a) {

    var b = a * 2;

    function bar(c) {
        console.log( a, b, c );
    }

    bar(b * 3);
	}
	
	foo( 2 ); // 2, 4, 12

这段示例代码中有三个嵌套作用域。将这些作用域想象成一个装在另一个的气泡能有助于你的理解。

<img src="fig2.png" width="500">

气泡1围绕的部分是全局作用域，它只有一个标识符：`foo`。

气泡2围绕的部分是`foo`的作用域，它包含三个标识符：`a`，`bar`和`b`。

气泡3围绕的部分是`bar`的作用域，它仅仅包含一个标识符：`c`。

作用域气泡是根据作用域代码块被编写的所在地来定义的，每个都是内嵌在另一个的内部，等等。在下一章，我们会讨论作用域的其他单元，但是现在，我们仅仅假设每一个函数都创建了一个新的作用域气泡。

`bar`的气泡整体被包含在`foo`的气泡中，因为（也仅因为）这里就是我们定义函数`bar`的地方。

注意这些内嵌的气泡都是严格内嵌的。我们并不是讨论维恩图那种气泡可以穿过其他气泡边界的情况。换句话说，没有一个函数的气泡可以同时（部分）存在于两个外部的气泡中，因为没有函数可以部分处在两个父函数的内部。

## 查找

这些作用域气泡的结构以及相对的位置关系完全地向引擎解释了它查找一个标识符时需要的所有位置。

在上面的代码片段中，引擎执行`console.log(..)`语句并去查找三个被引用的变量`a`，`b`和`c`。它首先从最内部的作用域气泡查找，也就是`bar(..)`函数的作用域。它在那里找不到`a`，因此它往上一层，到达距离次近的作用域气泡，也就是函数`foo(..)`的作用域。然后它找到了`a`，于是就是用这个`a`。对于`b`也是同样。而对于`c`，它会在`bar(..)`的内部被找到。

如果同时有一个`c`在`bar(..)`的内部和`foo(..)`的内部，那么`console.log(..)`语句会找到并使用`bar(..)`内部的那个，而永远不会获得`foo(..)`中的。

**作用域一旦发现第一个匹配的结果时就停止查找。**同名的标识符可以在内嵌作用域的多个层被定义，这被称为“投影”（内部的标识符“投影”到外部的标识符）。无论有没有投影，作用域查找总是从当前正在被执行的最内部的作用域开始，然后沿着向外/向上的方向直到找到第一个匹配，然后停止。

**注：**全局变量同时自动的成为全局对象（在浏览器中是`window`）的属性，因此引用一个全局对象可以不直接通过它的词法名称，而可以间接地以全局对象的属性的方式引用。

	windows.a
	
这一技术使得我们可以访问因为投影而无法被直接访问到的全局变量。但是，非全局的被投影的变量则无法被访问到。

无论一个函数从哪里被调用，或如何被调用，它的词法作用域**仅仅**被函数所声明的地方定义。

词法作用域查找的过程只适用于主标识符，例如`a`，`b`和`c`。如果你在代码中有一个对`foo.bar.baz`的引用，词法作用域的查找只会去找到`foo`标识符，一旦它定义了这个变量，对象属性访问规则则会继续接管去分别处理`bar`和`baz`属性。

# 欺骗词法分析器

如果作用域完全只通过函数声明的地方被定义，它就是完全的编写时决定的，既然如此我们怎么才能在运行时“修改”（欺骗）词法作用域呢？

JavaScript有两种机制可以实现这个功能。它们都在更外部的社区中被认为是错误的实现而不建议在你的代码中使用。但是这种反对其实往往错过了最重要的一点：**欺骗词法作用域会导致性能降低。**

在我解释性能问题之前，我们先来看看这两种机制是如何运作的。

## `eval`

JavaScript中的`eval(..)`函数接受一个字符串作为参数，并将其内容视为在程序当前时刻被编写的代码。换句话说，你可以通过编程的方式在你编写的代码内部生成代码，并执行该生成的代码就像它在编写程序时就已经在那里了一样。

在阳光下评估一下`eval(..)`，我们应该明白`eval(..)`是如何允许你通过欺骗、假装自己是编写代码时刻的代码（即词法时代码）的方式修改词法作用域环境的。

在`eval`代码执行后的代码行中，引擎不会“知晓”或“关心”之前的代码是否是动态解释的，也不管是否因此而修改了词法作用域环境。引擎只会像平常一样简单的执行词法作用域查询。

考虑一下下面的代码：

	function foo(str, a) {
	    eval( str ); // cheating!
	    console.log( a, b );
	}

	var b = 2;

	foo( "var b = 3;", 1 ); // 1, 3
	
这里，在`eval(..)`函数调用时的字符串`"var b = 3;"`被当做一直处在该处。因为这段代码刚刚申明了一个新变量`b`，它会修改当前`foo(..)`的词法作用域。事实上，如我们上文提到的那样，这段代码实际上在`foo(..)`的内部创建了变量`b`从而投影了在外部（全局）作用域上所定义的`b`。

当`console.log(..)`调用发生时，它会在`foo(..)`的作用域内同时发现`a`和`b`，而永远不会发现外部的`b`。因此它会输出"1, 3"而不是一般情况下的"1, 2"。

**注：**在本例中，为了简单起见，"代码"字符串是一串固定的文字。而它也很容易通过基于程序的逻辑添加特征量来程序化的创建。`eval(..)`通常用来执行动态创建的代码，因为从字符串中动态生成本来就是静态的代码和直接编写代码比起来不会有任何实际的好处。

如果`eval(..)`执行的一段字符串中包含一个或者多个声明（无论是变量还是函数），默认情况下这种行为会修改`eval(..)`所在的词法作用域。从技术的角度来说，`eval(..)`可以通过一些技巧被“间接地”调用（我们这里不做讨论），而会导致它在全局作用域中执行，从而达到修改它的目的。但是无论怎样，`eval(..)`都能在执行时修改我们当初编写时的词法作用域。

**注：**当`eval(..)`被用在严格模式下的程序时，它只能操作自己的词法作用域，这表示在`eval(..)`内部声明的变量实际上并不会修改围绕它的作用域。

	function foo(str) {
	   "use strict";
	   eval( str );
	   console.log( a ); // ReferenceError: a is not defined
	}

	foo( "var a = 2" );
	
