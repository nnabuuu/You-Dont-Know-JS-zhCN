# 你不懂JS：作用域和闭包

# 第四章：变量提升

现在，你应该对于以下内容已经相当熟悉了：包括作用域的概念，以及变量三如何根据它的位置和声明方式来不同来选定不同的作用域层级的。函数作用域和块级作用域的行为机制都相同：任何在该作用域内声明的变量都附着于该作用域自身。

但是对于作用域“如何处理在不同位置的变量声明”这个问题，有一些细微的地方我们需要解释一下：

## 先有鸡还是先有蛋？

有一种很容易犯的错误是认为你在JavaScript程序中所看到的每一行代码在程序运行时都是从上到下逐行解释的。这种看法大体上是正确的，但是这种假设有一个部分会导致对程序错误的理解。

考虑一下这段代码：

	a = 2;
	
	var a;
	
	console.log( a );

你觉得`console.log(..)`语句会打印出什么？

很多人会认为是`undefined`，因为`var a`语句在`a = 2`之后才出现，看起来很自然地，变量会被重定义，从而导致它的值变为默认的`undefined`。但是实际上，输出是`2`。

考虑另一段代码：

	console.log( a );
	
	var a = 2;

你可能会认为，因为之前的那段代码显示出代码的执行并不完全是从上到下，可能在这段代码中，结果也应该是输出`2`。而其他人可能认为，因为变量`a`是在它声明之前就被使用，因此这里一定会抛出一个`ReferenceError`。

很遗憾，两种猜测都是错误的，这里会打印出`undefined`。

**所以，这里到底发生了什么？**看起来我们遇到了一个先有鸡还是先有蛋的问题。哪一个在前呢？变量声明（“蛋”），还是变量赋值（“鸡”）？

## 看看编译器怎么说

要想回答这个问题，我们还是得回去参考第一章中我们对于编译器的讨论。回忆一下：引擎在解释代码之前实际上编译了你的JavaScript代码。编译阶段会找到所有的声明并将其和对应的作用域绑定。在第二章中我们演示了这就是所谓的词法作用域。

因此，最正确的理解是所有这些函数和变量声明都在最早执行，先于任何代码执行之前。

当你看到`var a = 2`时，你可能将其视为一句语句。而实际上JavaScript将其视为两句：`var a`以及`a = 2;`。第一句是变量声明，它在编译阶段执行。第二句则是赋值语句，被**留在原地**等待执行阶段。

我们的第一独爱代码实际上应该被这样理解：
```js
	var a;  
```

```js
	a = 2;
	
	console.log( a );
```

这里第一部分是编译部分，第二部分是执行部分。

类似的，我们的第二段代码实际上是：

```js
var a;
```

```
console.log( a );

a = 2;
```

因此，有一种对于这一过程的比喻是，变量和函数的声明实际上从它们原来的位置被“移动”到了所在代码的顶部。这就是“变量提升”这个说法的由来。

换句话说：**蛋（声明）在鸡（赋值）之前发生。**

**注：**只有变量自身被提升，而赋值语句或其他执行逻辑都被留在了原地。如果变量提升要重新调整我们所有的代码逻辑的话，这将会是一场灾难。

	foo();
	
	function foo() {
	    console.log( a ); // undefined
	
	    var a = 2;
	}

函数`foo`的声明（在这种情况下也包括了作为实际函数的隐藏内容）被提升了，因此第一行语句是可以被执行的。

同时要注意的是，变量提升是**基于作用域的**。因此在我们之前的代码片段中，场景非常简单，因为它只包含了全局作用域，在这里我们有`foo(..)`函数，它内部的`var a`被提升到了`foo(..)`的顶部。（而不是被提升到程序的顶部）。因此我们这个程序可以被解释成这样：

	function foo() {
	    var a;
	
	    console.log( a ); // undefined
	
	    a = 2;
	}
	
	foo();

如我们所见，函数声明被提升了。但是，而函数执行并不会。

	foo(); // not ReferenceError, but TypeError!
	
	var foo = function bar() {
	    // ...
	};

这里变量`foo`被提升并附着在这段程序的外部（全局）作用域中，因此`foo()`并不会导致一个`ReferenceError`。但是因为此时`foo`还没有被赋值（否则就是一个变量声明而不是变量表达式了）。因此`foo()`实际上是在尝试调用`undefined`的值，这样就导致了一个`TypeError`的非法操作。

