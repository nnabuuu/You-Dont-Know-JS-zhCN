# 你不懂JS：作用域和闭包

# 第四章：变量提升

现在，你应该对于以下内容已经相当熟悉了：包括作用域的概念，以及变量三如何根据它的位置和声明方式来不同来选定不同的作用域层级的。函数作用域和块级作用域的行为机制都相同：任何在该作用域内声明的变量都附着于该作用域自身。

但是对于作用域“如何处理在不同位置的变量声明”这个问题，有一些细微的地方我们需要解释一下：

## 先有鸡还是先有蛋？

有一种很容易犯的错误是认为你在JavaScript程序中所看到的每一行代码在程序运行时都是从上到下逐行解释的。这种看法大体上是正确的，但是这种假设有一个部分会导致对程序错误的理解。

考虑一下这段代码：

	a = 2;
	
	var a;
	
	console.log( a );

你觉得`console.log(..)`语句会打印出什么？

很多人会认为是`undefined`，因为`var a`语句在`a = 2`之后才出现，看起来很自然地，变量会被重定义，从而导致它的值变为默认的`undefined`。但是实际上，输出是`2`。

考虑另一段代码：

	console.log( a );
	
	var a = 2;

你可能会认为，因为之前的那段代码显示出代码的执行并不完全是从上到下，可能在这段代码中，结果也应该是输出`2`。而其他人可能认为，因为变量`a`是在它声明之前就被使用，因此这里一定会抛出一个`ReferenceError`。

很遗憾，两种猜测都是错误的，这里会打印出`undefined`。

**所以，这里到底发生了什么？**看起来我们遇到了一个先有鸡还是先有蛋的问题。哪一个在前呢？变量声明（“蛋”），还是变量赋值（“鸡”）？

## 看看编译器怎么说

要想回答这个问题，我们还是得回去参考第一章中我们对于编译器的讨论。回忆一下：引擎在解释代码之前实际上编译了你的JavaScript代码。编译阶段会找到所有的声明并将其和对应的作用域绑定。在第二章中我们演示了这就是所谓的词法作用域。

因此，最正确的理解是所有这些函数和变量声明都在最早执行，先于任何代码执行之前。

当你看到`var a = 2`时，你可能将其视为一句语句。而实际上JavaScript将其视为两句：`var a`以及`a = 2;`。第一句是变量声明，它在编译阶段执行。第二句则是赋值语句，被**留在原地**等待执行阶段。

我们的第一独爱代码实际上应该被这样理解：
```js
	var a;  
```

```js
	a = 2;
	
	console.log( a );
```

这里第一部分是编译部分，第二部分是执行部分。

类似的，我们的第二段代码实际上是：

```js
var a;
```

```
console.log( a );

a = 2;
```

因此，有一种对于这一过程的比喻是，变量和函数的声明实际上从它们原来的位置被“移动”到了所在代码的顶部。这就是“变量提升”这个说法的由来。

换句话说：**蛋（声明）在鸡（赋值）之前发生。**

**注：**只有变量自身被提升，而赋值语句或其他执行逻辑都被留在了原地。如果变量提升要重新调整我们所有的代码逻辑的话，这将会是一场灾难。

	foo();
	
	function foo() {
	    console.log( a ); // undefined
	
	    var a = 2;
	}

函数`foo`的声明（在这种情况下也包括了作为实际函数的隐藏内容）被提升了，因此第一行语句是可以被执行的。

同时要注意的是，变量提升是**基于作用域的**。因此在我们之前的代码片段中，场景非常简单，因为它只包含了全局作用域，在这里我们有`foo(..)`函数，它内部的`var a`被提升到了`foo(..)`的顶部。（而不是被提升到程序的顶部）。因此我们这个程序可以被解释成这样：

	function foo() {
	    var a;
	
	    console.log( a ); // undefined
	
	    a = 2;
	}
	
	foo();

如我们所见，函数声明被提升了。但是，而函数执行并不会。

	foo(); // not ReferenceError, but TypeError!
	
	var foo = function bar() {
	    // ...
	};

这里变量`foo`被提升并附着在这段程序的外部（全局）作用域中，因此`foo()`并不会导致一个`ReferenceError`。但是因为此时`foo`还没有被赋值（否则就是一个变量声明而不是变量表达式了）。因此`foo()`实际上是在尝试调用`undefined`的值，这样就导致了一个`TypeError`的非法操作。

同时，回忆一下，即使这是一个被命名了的函数表达式，其名称标识符在外部作用域中也是不可见的：

	foo(); // TypeError
	bar(); // ReferenceError
	
	var foo = function bar() {
	    // ...
	};

这段代码更准确的应该通过变量提升被解释为：

	var foo;
	
	foo(); // TypeError
	bar(); // ReferenceError
	
	foo = function() {
	    var bar = ...self...
	    // ...
	}

## 变量提升中函数优先

函数声明和变量声明都会被提升。但是它们之间有一个微小的区别在于：函数先被提升，然后才轮到变量。

考虑下面这段代码：

	foo(); // 1
	
	var foo;
	
	function foo() {
	    console.log( 1 );
	}
	
	foo = function() {
	    console.log( 2 );
	};

这里打印出的是`1`而不是`2`！这段代码被引擎解释为：

	function foo() {
	    console.log( 1 );
	}
	
	foo(); // 1
	
	foo = function() {
	    console.log( 2 );
	};

注意原代码中的`var foo`实际上是重复声明，它会被忽略掉，即使在是在`function foo() ...`声明之前出现，因为函数声明的提升是在普通变量提升前。

但是，虽然重复的`var`声明会被忽略，而重复的函数声明却回覆盖之前的声明。

	foo(); // 3
	
	function foo() {
	    console.log( 1 );
	}
	
	var foo = function() {
	    console.log( 2 );
	};
	
	function foo() {
	    console.log( 3 );
	}

尽管所有这些看起来都只是一些理论上的细枝末节的玩意，但是它实际上表明了在同一作用域中重复定义函数绝对是一个坏主意。它往往会导致令人疑惑的结果。

在普通代码块中的函数声明会被提升到外部作用域的顶部，而不是这个代码块的条件分支中：

	foo(); // "b"
	
	var a = true;
	if (a) {
	   function foo() { console.log( "a" ); }
	}
	else {
	   function foo() { console.log( "b" ); }
	}

但是请注意，这种行为在JavaScript中并没有被确定描述，因此它可能会在将来版本的JavaScript中改变。因此最好的方式是完全避免这种在代码块中声明函数的做法。

# 章节回顾（给太长不看的人看的）

我们在阅读代码时会将`var a = 2;`是为一个语句，但是JavaScript引擎并不这样认为。它将这段代码拆分为`var a`和`a = 2`两个单独语句。第一句在编译阶段完成，第二句在执行阶段完成。

这样做的结果是，在作用域中的所有声明，无论出现在何处，都会在代码自身执行前被处理。你可以认为这些（函数以及变量的）声明被”移动“到了它们各自作用域的顶部，我们将这一行为称为“变量提升”。

只有声明语句被提升，赋值语句（即使是函数表达式赋值）则不会被提升。

对于重名标识符的声明要千万当心，特别是在普通var声明和函数声明中的重名声明 -- 如果你这样做你会遇到大麻烦！