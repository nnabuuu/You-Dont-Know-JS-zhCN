# 你不懂JS：作用域和闭包

#第一章：什么是作用域？

几乎所有编程语言的最重要的基本范式之一，就是在变量中存储值，并在之后再次获取或者修改这个值。事实上，向变量内存储和获取一个值的能力就是给予了一个程序状态。

如果没有这个概念，程序可能可以执行一些任务，但它们会非常有限，并且一点也不有趣。

但是再我们多程序中引入变量将会产生一个非常有趣的，我们现在要解决的问题：这些变量是存活着的吗？换句话说，它们被存储在哪里？并且最重要的是，我们的程序在需要它们时是如何找到它们的？

这些问题表明了对于在何处存储变量规范定义的规则集合的需求，为了在之后能找到这些变量。我们将这一规范集合称为：作用域。

但是，这些作用域规则是在何处、并以何种方式被设置的呢？

# 编译器理论

这也许是不言而喻的、或者也可能让你相当吃惊（取决于你使用其他语言的经验等级），但尽管JavaScript属于一般“动态”或者“解释型”语言类别，它实际上是一种编译型语言。它不像很多传统编译型语言一样在事先就编译好，也不是在多系统平台可移植的编译结果。

但不管怎样，JavaScript引擎也和很多传统语言编译器一样，尽管可能比我们通常意识到的更复杂一些，执行很多相同的步骤。

在传统编译型语言的流程中，一部分的源代码（即你的程序），通常在执行之前会经历三个步骤，我们通常称之为“编译”。

1. **分词/词法分析：**将一串字符分解为（对该语言）有意义的块，即称为token。例如，考虑这个程序`var a = 2;`。程序很可能将其分解为这些token：`var`，`a`，`=`，`2`和`;`。空格符可能会也可能不会被持久化为一个token，这取决于它是否是有意义的。

	**注：**分词与词法分析之间的区别非常的微妙以及学术化，但其区别在于这些token被定义为无状态还是有状态的。简而言之，如果编译器需要调用有状态的解析规则来确定是否`a`应该被认为是一个单独的token还是另一个token的一部分，则这种方式是词法分析。

2. **解析：**处理一个token的流（数组），将其转化为一个内部元素的树，它们共同代表程序的语法结构。这棵树被成为一个"AST"（**A**bstract **S**yntax **T**ree，抽象语法树）。

	`var a = 2;`的抽象语法树，可能以一个顶层元素`变量声明`开始，它包含一个子节点称为`标识符`（它的值是`a`），以及另一个子节点称为`赋值表达式`，它有一个子节点称为`数值类型`（其值为`2`）。
	
3. **代码生成：**获取抽象语法树并将其转化为可执行代码的过程。这部分随语言、目标平台的不同，会产生非常大的差异性。

	因此，为避免陷入细节的泥沼中，我们只是挥挥手并且假设有一种方法获取我们之前所述的`var a = 2;`的抽象语法树，然后将其转化为一组真正的机器指令来创建一个名为`a`的变量（包括分配内存），然后将一个值存入`a`中。
	
	**注：**有关引擎如何管理系统资源的细节远比我们将要挖掘的内容深得多，因此我们只是理所当然的认为引擎可以如所需的那样创建和存储变量。
	
JavaScript引擎比这三个步骤（像大多数其他语言编译器那样）更复杂。例如，在解析和代码生成的过程中，有一些特定的步骤来优化执行性能，包括压缩冗余元素等等。

因此我在这里只是大致讲解。但是我想你很快会知道为什么我们提到的这些，即使在一个很高的层面上来看，也是非常相关的。

首先，JavaScript引擎并不像其他引擎一样有足够多宝贵的时间来进行优化，因为JavaScript的编译并不像其他语言那样发生于之前的一个构建步骤中。

对于JavaScript而言，在多数情况下，编译发生在代码执行前的几微秒（甚至更短）内。为了保证最好的性能，JS引擎使用了多种技巧（例如JIT，它使用了“懒编译”以及“热重编译”等技术。），这些都远远超出了我们在这里要讨论的“作用域”的范围。

让我们就这样说，出于简单考虑，任何JavaScript片段在执行前（通常是刚执行前！）都需要被编译。因此JS编译器会先获取并编译程序`var a = 2;`，然后准备好执行它，通常会立即执行。

# 理解作用域

我们学习作用域的方式是通过对话的方式想象它的过程。但是，这里是谁在对话呢？

## 选派角色

让我们来见见和程序`var a = 2;`处理交互的角色，这样我们会理解之后我们马上要见到的他们的对话：

1. 引擎： 负责从开始到结束的编译以及执行我们的JavaScript程序
2. 编译器： 引擎的朋友，处理所有的解析和代码生成工作（见之前小节）
3. 作用域：引擎的另一个朋友，收集并维护一个查找左右声明的标识符（变量）的列表并，对这些变量对当前执行代码的可访问性实行一组严格的规则。

为了完全理解JavaScript是如何工作的，你必须开始像引擎（和它的朋友）一样思考，问它们所问的问题，并同时回答这些问题。

## 来来回回

当你看到程序`var a = 2;`时，你很可能认为那是一个语句。但对于我们的新朋友引擎来说，它看到的并不是这样。事实上，引擎看到了两个不同的语句，其中一句由编译器在编译时处理，另一个由引擎在执行时处理。

因此，让我们来分解一下引擎和它的朋友是如何处理程序`var a = 2;`的。

编译器要对程序做的第一件事情就是完成词法分析来将其分解为token，然后会解析到树中。但是当编译器执行代码生成时，它会可能会使用和计划的不同的方式处理该程序。

一个合理的假设是，编译器会生成可以通过这种伪代码相加的代码：“为一个变量分配内存，将其命名为`a`，然后将值`2`赋予给这个变量”。不幸的是，这并不准确。

相反地，编译器会这样处理：

1. 遇见`var a`, 编译器向作用域询问是否变量`a`已经存在于那个特定的作用域集合中。如果是的话，编译器忽略该声明并继续。否则，编译器要求作用域为那个作用域集合声明一个名为`a`的新变量。

2. 编译器然后为引擎产生之后会执行的代码，为了处理`a = 2`语句。引擎所运行的代码会先询问作用域是否有一个名为`a`的变量可以在当前作用域集合中被访问。如果是的话，引擎会使用那个变量。否则，引擎会像其他地方寻找。（见下文的作用域章节）

如果引擎最终发现了一个变量，它会把值`2`赋予给它。否则，引擎会挥手并报出一个错误！

总结：对一个变量的赋值，有两个不同的操作被执行了。第一，编译器声明一个变量（如果在当前作用域中之前没有声明的话）， 第二，在执行时，引擎在作用域中寻找该变量，如果找到的话，赋值给它。

## 编译器怎么说

我们需要了解多一点的编译器专业术语来理解更深入的内容。

当引擎在执行编译器在步骤2产生的代码时，它需要查询变量`a`以确定它是否已经被声明过，这个查询行为是需要求助于作用域的。但是引擎查找时使用的变量类型将影响到查询结果。

在我们的场景中，引擎将执行一个"LHS"的操作来查询变量`a`。另外一种查询类型被称为"RHS"。

我打赌你肯定能猜到"L"和"R"的意思。他们表示"左边"和"右边"。

到底是什么的左/右边呢？其实是**赋值操作**的左/右边。

换句话说，当变量出现在赋值操作的左边时，所执行的是一个LHS查询。而当变量出现在赋值操作的右边时，所执行的是一个RHS查询。

事实上，让我们说得更准确些。在我们的场景中，RHS查询与"从一个变量中获取它的值"的操作是无法区分的。而LHS查询则是尝试获取变量容器自身，以便给它赋值。因此，在这种语境下，实际上RHS并不是表示"赋值操作的右边"，更准确的说，它仅仅表示"不是在左边"。

我们现在也可以肤浅的这样认为："RHS"表示"检索他/她的来源"，这意味着RHS表示"去获取...的值"。

让我们再深挖一点。

当我像这样写的时候：

	console.log( a );
	
这里对于`a`的引用是一个RHS引用，因为在这里，`a`没有被赋予任何值。相反，我们是在搜索并获取`a`的值，这样它的值就会被传递给`console.log(..)`.

相比之下：

	a = 2;
	
这里对`a`的引用是一个LHS引用，因为我们实际上并不关心当前`a`的值是什么，我们只是想找到该变量并将其作为`= 2`赋值操作的目标。

**注：**LHS和RHS的意思是"赋值操作的左/右边"并不完全照字面上的意思是"`=`号赋值操作的左/右边"。有很多其他方式进行赋值，因此最好在概念上这样理解："LHS是赋值语句的目标"，"RHS是赋值语句的来源"。

考虑下面这个程序，它同时包含了LHS和RHS引用：

	function foo(a) {
		console.log( a ); // 2
	}
	
	foo( 2 );
	
最后一行的调用的`foo(..)`作为一个函数调用请求一个对`foo`的引用，这意味着"去找到`foo`的值，然后拿来给我"。并且，因为`(..)`表示是`foo`应该要执行的值，因此`foo`最好是一个函数才对！

这里有一个很巧妙的但是重要的赋值语句。**你看出来了吗？**

你可能漏掉了这个代码片段中隐含的`a = 2`。它在当值`2`被作为一个参数传递给`foo(..)`函数的时候发生，此时值`2`被传递给了参数`a`。为了（隐式）赋值给参数`a`，这里执行了一个LHS查询。

这里也有一个对`a`的值的RHS引用，它的值被传递给了`console.log(..)`。`console.log(..)`需要一个引用来执行。这时候有一个RHS查询找到`console`对象，然后会产生一个属性判断以确定是否它含有一个名为`log`的方法。

最终，我们可以将其概念化：有一个LHS/RHS的交换，传递值`2`（通过变量`a`的RHS查询）带`log(..)`中。和`log(..)`的本地实现不同，我们假设它包含参数，其中的第一个（可能叫做`arg1`）会在将其赋值为`2`前进行一次LHS引用查询。

**注：**你可能会尝试将函数声明`function foo(){..`概念化为一个普通的变量声明和赋值，就像`var foo`以及`foo = function(a){..`那样。如果是这样的话，看起来函数声明出发了一次LHS查询。

然而，有一个细微但重要的区别在于，编译器在代码生成阶段一同处理声明和变量定义，这样当引擎执行代码时，并没有必要给`foo`赋予一个函数值。因此，将函数定义想象成一次我们这里所讨论的LHS查询赋值是不太恰当的。

## 引擎/作用域之间的对话

	function foo(a) {
		console.log( a ); // 2
	}
	
	foo( 2 );
	
让我们想象一下，把上面的程序（会执行这段代码）想象成一次对话。那么它们的交谈可能会像是这样：

**引擎：**嘿作用域，我这里有一个对`foo`的RHS引用，你听说过它吗？

**作用域：**是的我见过。编译器在一秒钟以前声明了它。它是一个函数，给。

**引擎：**太棒了，谢谢！好，那么我开始执行`foo`了。

**引擎：**嘿，作用域。我这里有一个对`a`的LHS引用，你听说过它吗？

**作用域：**是的，我听说过。编译器最近刚刚将它声明为`foo`的正式参数。给。

**引擎：**作用域你总是这么有用。再次感谢。现在我要看是将`2`赋值给`a`了。

**引擎：**嘿，作用域。对不起又要麻烦你了。需要一次RHS搜索去查找`console`。你听说过吗？

**作用域：**没关系，引擎，我本来就是做这个的。好的，我现在拿到了`console`，他是一个内置的对象，给。

**引擎：**完美！我来找看看`log(..)`。很好，拿到了，这是一个函数。

**引擎：**yo，作用域。你可以帮我拿到`a`的RHS引用吗？我想我还记得它，但是我只是想跟你二次确认一下。

**作用域：**你是对的，引擎。它还是同样的东西没变，给。

**引擎：**酷！现在我把`a`的值，也就是`2`，传递到`log(..)`中。

...


## 小测验

检验一下你到目前为止的理解。确保你已经作为引擎的角色开始了演出，并和作用域进行了一次“对话”：

	function foo(a) {
		var b = a;
		return a + b;
	}
	
	var c = foo( 2 );

1. 找到所有的LHS查询（共有3个！）。
2. 找到所有的RHS查询（共有4个！）。

**注：**你可以在章节回顾中找到测验答案

## 作用域嵌套

我们说过，作用域是一组用来通过变量标识名查询变量的规则。但实际上，往往有多于一个的作用域需要考虑。

就像代码块或函数被嵌套在另一个块或函数内一样，作用域也是嵌套在其他作用域中的。因此，如果一个变量无法在当前的作用域中被找到，那么引擎会向更外一层的作用域容器进行查询，直到找到这个元素或直到到达最外层（即global）作用域。

考虑一下这段代码：

	function foo(a) {
	    console.log( a + b );
	}
	
	var b = 2;
	
	foo( 2 ); // 4

对`b`的RHS查询无法在函数`foo`内部完成，但是却可以在外部的作用域（在这里是global）中完成。

所以让我们再去听听引擎和作用域之间的对话，我们会听到：

**引擎：**嘿，`foo`作用域，你见过`b`吗？我对它有一个RHS引用。

**作用域：**没听过，玩儿蛋去。

**引擎：**嘿，`foo`外面的那个作用域，噢，你是golbal作用域，好吧。你见过`b`吗？我对它有一个RHS引用。

**作用域：**当然见过啦，给。

遍历嵌套作用域的简单规则是：引擎从当前执行的作用域开始，寻找那里的变量。如果没找到则继续向上层寻找。如果到达了最外层的golbal作用域，搜索停止，要么找到该变量要么没找到。

## 举个例子

为了将嵌套作用域的处理方式可视化，我们可以看看这幢大厦。

<img src="fig1.png" width="250">

这幢大楼代表着我们程序的嵌套作用域规则集合。大楼的第一层代表你当前执行的作用域，无论你在程序的任何位置都是如此。而最高的那一层则代表blobal作用域。

你通过在本层查询的方式解决LHS和RHS引用，如果你没有找到，坐电梯抵达下一层，继续寻找。一旦你到达了最高一层（global作用域），你要么找到这个变量，要么没找到，你也只能停下来了。

## 错误

为什么我们需要区分LHS或者RHS呢？

因为这两种搜索对于变量没有被声明的情况（没有在任何所查询的作用域中被找到）的处理方式是完全不同的。

考虑一下这段代码：

	function foo(a) {
	    console.log( a + b );
	    b = a;
	}
	
	foo( 2 );

当对`b`的RHS查询第一次发生时，将无法找到结果。这个时候它就被称为一个“未声明”变量，因为它没有在作用域中被找到。

如果一次RHS查询没有在任何嵌套作用域中找到变量，那么它会导致引擎抛出一个`ReferenceError`错误。这里要注意的是，这个错误的类型是`ReferenceError`。

相比之下，如果引擎执行LHS查询直到最高层（global作用域）而没有发现它的话，如果程序不是执行在"严格模式"[^note-strictmode]的话，那么global作用域会用这个名字**在global作用域中**创建一个新的变量，然后返回给引擎。

*“不，我没有看到过这个变量，但是我可以帮你创建一个。”*

"严格模式"[^note-strictmode]是在ES5中被添加的，它和普通模式有非常多的行为区别。其中一个就是不允许自动/隐式的创建全局变量。在这种模式下，不会有全局作用域的变量被返回给LHS查询，而引擎则会和RHS失败的情况类似，抛出一个`ReferenceError`。

如果一个变量被RHS查询找到，但是你对它的值作一些不可能的操作，例如像一个函数一样执行一个不是函数的值，或者从`null`或`undefined`值中引用一个属性，这个时候引擎会抛出另一种错误，称为`TypeError`。

`ReferenceError`是和作用域处理失败相关的，而`TypeError`则表明作用域处理是成功的，但是对于获取后的结果的操作是不合法的。

# 章节回顾 （给太长不看的人看的）

作用域是一组用来定义哪里以及怎样找到一个变量的规则。这个查询可以是用来给变量赋值，即LHS(left-hand-side)引用，或者也可以是用来从变量中获取它的值，即RHS(right-hand-side)引用。

LHS引用的对象是赋值操作的结果。作用域相关的赋值可以使用`=`操作符也可以是在给函数传参中。

JavaScript引擎会在代码执行之前先进行编译，通过编译，类似于`var a = 2;`的语句会被分解成两个单独的阶段：

1. 首先，通过`var a`语句在该作用域中声明它。这一步是在最开始，代码执行前就运行的。

2. 然后，通过`a = 2`查找该变量（通过LHS引用），如果发现该变量的话就给它赋值。

LHS引用和RHS引用都从当前的作用域开始，如果需要的话（如果没有在当前作用域找到目标的话），它们会沿着嵌套作用域的上方继续搜索，每次都向更外的作用域继续寻找标识符，直到到达全局作用域并停止，要么找到，要么没有找到。

不成功的RHS引用会导致`ReferenceError`的抛出。不成功的LHS引用会在非“严格模式”中导致自动隐式创建一个全局同名变量，在严格模式下会抛出`ReferenceError`。

## 小测验答案

	function foo(a) {
		var b = a;
		return a + b;
	}
	
	var c = foo( 2 );

1. 找到所有的LHS查询（共有3个！）。
	
	`c = ..`，`a = 2`（隐式参数赋值）和`b = ..`

2. 找到所有的RHS查询（共有4个！）。

	`foo(2..`，`= a`，`a + ..` 和 `.. + b`

[^note-strictmode]: MDN: [Strict Mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)