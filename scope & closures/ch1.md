# 你不懂JS：作用域和闭包

#第一章：什么是作用域？

几乎所有编程语言的最重要的基本范式之一，就是在变量中存储值，并在之后再次获取或者修改这个值。事实上，向变量内存储和获取一个值的能力就是给予了一个程序状态。

如果没有这个概念，程序可能可以执行一些任务，但它们会非常有限，并且一点也不有趣。

但是再我们多程序中引入变量将会产生一个非常有趣的，我们现在要解决的问题：这些变量是存活着的吗？换句话说，它们被存储在哪里？并且最重要的是，我们的程序在需要它们时是如何找到它们的？

这些问题表明了对于在何处存储变量规范定义的规则集合的需求，为了在之后能找到这些变量。我们将这一规范集合称为：作用域。

但是，这些作用域规则是在何处、并以何种方式被设置的呢？

# 编译器理论

这也许是不言而喻的、或者也可能让你相当吃惊（取决于你使用其他语言的经验等级），但尽管JavaScript属于一般“动态”或者“解释型”语言类别，它实际上是一种编译型语言。它不像很多传统编译型语言一样在事先就编译好，也不是在多系统平台可移植的编译结果。

但不管怎样，JavaScript引擎也和很多传统语言编译器一样，尽管可能比我们通常意识到的更复杂一些，执行很多相同的步骤。

在传统编译型语言的流程中，一部分的源代码（即你的程序），通常在执行之前会经历三个步骤，我们通常称之为“编译”。

1. **分词/词法分析：**将一串字符分解为（对该语言）有意义的块，即称为token。例如，考虑这个程序`var a = 2;`。程序很可能将其分解为这些token：`var`，`a`，`=`，`2`和`;`。空格符可能会也可能不会被持久化为一个token，这取决于它是否是有意义的。

	**注：**分词与词法分析之间的区别非常的微妙以及学术化，但其区别在于这些token被定义为无状态还是有状态的。简而言之，如果编译器需要调用有状态的解析规则来确定是否`a`应该被认为是一个单独的token还是另一个token的一部分，则这种方式是词法分析。

2. **解析：**处理一个token的流（数组），将其转化为一个内部元素的树，它们共同代表程序的语法结构。这棵树被成为一个"AST"（**A**bstract **S**yntax **T**ree，抽象语法树）。

	`var a = 2;`的抽象语法树，可能以一个顶层元素`变量声明`开始，它包含一个子节点称为`标识符`（它的值是`a`），以及另一个子节点称为`赋值表达式`，它有一个子节点称为`数值类型`（其值为`2`）。
	
3. **代码生成：**获取抽象语法树并将其转化为可执行代码的过程。这部分随语言、目标平台的不同，会产生非常大的差异性。

	因此，为避免陷入细节的泥沼中，我们只是挥挥手并且假设有一种方法获取我们之前所述的`var a = 2;`的抽象语法树，然后将其转化为一组真正的机器指令来创建一个名为`a`的变量（包括分配内存），然后将一个值存入`a`中。
	
	**注：**有关引擎如何管理系统资源的细节远比我们将要挖掘的内容深得多，因此我们只是理所当然的认为引擎可以如所需的那样创建和存储变量。
	
JavaScript引擎比这三个步骤（像大多数其他语言编译器那样）更复杂。例如，在解析和代码生成的过程中，有一些特定的步骤来优化执行性能，包括压缩冗余元素等等。

因此我在这里只是大致讲解。但是我想你很快会知道为什么我们提到的这些，即使在一个很高的层面上来看，也是非常相关的。

首先，JavaScript引擎并不像其他引擎一样有足够多宝贵的时间来进行优化，因为JavaScript的编译并不像其他语言那样发生于之前的一个构建步骤中。

对于JavaScript而言，在多数情况下，编译发生在代码执行前的几微秒（甚至更短）内。为了保证最好的性能，JS引擎使用了多种技巧（例如JIT，它使用了“懒编译”以及“热重编译”等技术。），这些都远远超出了我们在这里要讨论的“作用域”的范围。

让我们就这样说，出于简单考虑，任何JavaScript片段在执行前（通常是刚执行前！）都需要被编译。因此JS编译器会先获取并编译程序`var a = 2;`，然后准备好执行它，通常会立即执行。

# 理解作用域

我们学习作用域的方式是通过对话的方式想象它的过程。但是，这里是谁在对话呢？

## 选派角色

让我们来见见和程序`var a = 2;`处理交互的角色，这样我们会理解之后我们马上要见到的他们的对话：

1. 引擎： 负责从开始到结束的编译以及执行我们的JavaScript程序
2. 编译器： 引擎的朋友，处理所有的解析和代码生成工作（见之前小节）
3. 作用域：引擎的另一个朋友，收集并维护一个查找左右声明的标识符（变量）的列表并，对这些变量对当前执行代码的可访问性实行一组严格的规则。

为了完全理解JavaScript是如何工作的，你必须开始像引擎（和它的朋友）一样思考，问它们所问的问题，并同时回答这些问题。

## 来来回回

当你看到程序`var a = 2;`时，你很可能认为那是一个语句。但对于我们的新朋友引擎来说，它看到的并不是这样。事实上，引擎看到了两个不同的语句，其中一句由编译器在编译时处理，另一个由引擎在执行时处理。

因此，让我们来分解一下引擎和它的朋友是如何处理程序`var a = 2;`的。

编译器要对程序做的第一件事情就是完成词法分析来将其分解为token，然后会解析到树中。但是当编译器执行代码生成时，它会可能会使用和计划的不同的方式处理该程序。

一个合理的假设是，编译器会生成可以通过这种伪代码相加的代码：“为一个变量分配内存，将其命名为`a`，然后将值`2`赋予给这个变量”。不幸的是，这并不准确。

相反地，编译器会这样处理：

1. 遇见`var a`, 编译器向作用域询问是否变量`a`已经存在于那个特定的作用域集合中。如果是的话，编译器忽略该声明并继续。否则，编译器要求作用域为那个作用域集合声明一个名为`a`的新变量。

2. 编译器然后为引擎产生之后会执行的代码，为了处理`a = 2`语句。引擎所运行的代码会先询问作用域是否有一个名为`a`的变量可以在当前作用域集合中被访问。如果是的话，引擎会使用那个变量。否则，引擎会像其他地方寻找。（见下文的作用域章节）

如果引擎最终发现了一个变量，它会把值`2`赋予给它。否则，引擎会挥手并报出一个错误！

总结：对一个变量的赋值，有两个不同的操作被执行了。第一，编译器声明一个变量（如果在当前作用域中之前没有声明的话）， 第二，在执行时，引擎在作用域中寻找该变量，如果找到的话，赋值给它。

## 编译器怎么说

我们需要了解多一点的编译器专业术语来理解更深入的内容。

当引擎在执行编译器在步骤2产生的代码时，它需要查询变量`a`以确定它是否已经被声明过，这个查询行为是需要求助于作用域的。但是引擎查找时使用的变量类型将影响到查询结果。

在我们的场景中，引擎将执行一个"LHS"的操作来查询变量`a`。另外一种查询类型被称为"RHS"。

我打赌你肯定能猜到"L"和"R"的意思。他们表示"左边"和"右边"。

到底是什么的左/右边呢？其实是**赋值操作**的左/右边。

换句话说，当变量出现在赋值操作的左边时，所执行的是一个LHS查询。而当变量出现在赋值操作的右边时，所执行的是一个RHS查询。

事实上，让我们说得更准确些。在我们的场景中，RHS查询与"从一个变量中获取它的值"的操作是无法区分的。而LHS查询则是尝试获取变量容器自身，以便给它赋值。因此，在这种语境下，实际上RHS并不是表示"赋值操作的右边"，更准确的说，它仅仅表示"不是在左边"。

我们现在也可以肤浅的这样认为："RHS"表示"获取它的原始值"