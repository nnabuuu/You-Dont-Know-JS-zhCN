# 你不懂JS：作用域和闭包

#第一章：什么是作用域？

几乎所有编程语言的最重要的基本范式之一，就是在变量中存储值，并在之后再次获取或者修改这个值。事实上，向变量内存储和获取一个值的能力就是给予了一个程序状态。

如果没有这个概念，程序可能可以执行一些任务，但它们会非常有限，并且一点也不有趣。

但是再我们多程序中引入变量将会产生一个非常有趣的，我们现在要解决的问题：这些变量是存活着的吗？换句话说，它们被存储在哪里？并且最重要的是，我们的程序在需要它们时是如何找到它们的？

这些问题表明了对于在何处存储变量规范定义的规则集合的需求，为了在之后能找到这些变量。我们将这一规范集合称为：作用域。

但是，这些作用域规则是在何处、并以何种方式被设置的呢？

# 编译器理论

这也许是不言而喻的、或者也可能让你相当吃惊（取决于你使用其他语言的经验等级），但尽管JavaScript属于一般“动态”或者“解释型”语言类别，它实际上是一种编译型语言。它不像很多传统编译型语言一样在事先就编译好，也不是在多系统平台可移植的编译结果。

但不管怎样，JavaScript引擎也和很多传统语言编译器一样，尽管可能比我们通常意识到的更复杂一些，执行很多相同的步骤。

在传统编译型语言的流程中，一部分的源代码（即你的程序），通常在执行之前会经历三个步骤，我们通常称之为“编译”。

1. **分词/词法分析：**将一串字符分解为（对该语言）有意义的块，即称为token。例如，考虑这个程序`var a = 2;`。程序很可能将其分解为这些token：`var`，`a`，`=`，`2`和`;`。空格符可能会也可能不会被持久化为一个token，这取决于它是否是有意义的。

	**注：**分词与词法分析之间的区别非常的微妙以及学术化，但其区别在于这些token被定义为无状态还是有状态的。简而言之，如果编译器需要调用有状态的解析规则来确定是否`a`应该被认为是一个单独的token还是另一个token的一部分，则这种方式是词法分析。

2. **解析：**处理一个token的流（数组），将其转化为一个内部元素的树，它们共同代表程序的语法结构。这棵树被成为一个"AST"（**A**bstract **S**yntax **T**ree，抽象语法树）。

	`var a = 2;`的抽象语法树，可能以一个顶层元素`变量声明`开始，它包含一个子节点称为`标识符`（它的值是`a`），以及另一个子节点称为`赋值表达式`，它有一个子节点称为`数值类型`（其值为`2`）。
	
3. **代码生成：**获取抽象语法树并将其转化为可执行代码的过程。这部分随语言、目标平台的不同，会产生非常大的差异性。

	因此，为避免陷入细节的泥沼中，我们只是挥挥手并且假设有一种方法获取我们之前所述的`var a = 2;`的抽象语法树，然后将其转化为一组真正的机器指令来创建一个名为`a`的变量（包括分配内存），然后将一个值存入`a`中。
	
	**注：**有关引擎如何管理系统资源的细节远比我们将要挖掘的内容深得多，因此我们只是理所当然的认为引擎可以如所需的那样创建和存储变量。
	
JavaScript引擎比这三个步骤（像大多数其他语言编译器那样）更复杂。例如，在解析和代码生成的过程中，有一些特定的步骤来优化执行性能，包括压缩冗余元素等等。

因此我在这里只是大致讲解。但是我想你很快会知道为什么我们提到的这些，即使在一个很高的层面上来看，也是非常相关的。

首先，JavaScript引擎并不像其他引擎一样有足够多宝贵的时间来进行优化，因为JavaScript的编译并不像其他语言那样发生于之前的一个构建步骤中。

对于JavaScript而言，在多数情况下，编译发生在代码执行前的几微秒（甚至更短）内。为了保证最好的性能，JS引擎使用了多种技巧（例如JIT，它使用了“懒编译”以及“热重编译”等技术。），这些都远远超出了我们在这里要讨论的“作用域”的范围。

让我们就这样说，出于简单考虑，任何JavaScript片段在执行前（通常是刚执行前！）都需要被编译。因此JS编译器会先获取并编译程序`var a = 2;`，然后准备好执行它，通常会立即执行。

