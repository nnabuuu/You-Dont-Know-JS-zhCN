# 你不懂JS：作用域和闭包

# 第三章：函数和块作用域

我们在第二种了解到，作用域由一系列的像容器的“气泡”组成，内部会定义标识符（变量，函数）。这些气泡整齐地嵌套在一起，并且这个嵌套关系是在编写时定义的。

但是怎样才能创建一个新的气泡？只能通过函数吗？JavaScript中友其他的结构来创建作用域气泡吗？

## 来源于函数的作用域

这些问题的最普遍答案是JavaScript具有基于函数的作用域。也就是说，你所声明的每个函数都会为它自己创建一个气泡，其他任何结构都无法创建它们自己的作用域气泡。我们会在之后看到，这并不是那么准确。

但是首先，让我们探索一下函数作用域以及它的含义。

考虑如下代码：

	function foo(a) {
	    var b = 2;

	    // some code

	    function bar() {
	        // ...
	    }

	    // more code

	    var c = 3;
	}
	
在这段代码中，`foo(..)`的作用域气泡包含了标识符`a`，`b`，`c`以及`bar`。它和变量声明出现的位置**没有关系**，无论声明在何处出现，变量或函数都属于该作用域气泡。我们在下一章会探讨一下这究竟是如何实现的。

`bar(..)`拥有自己的作用域气泡。全局作用域也是，它只有一个附在它之上的标识符：`foo`。

因为`a`，`b`，`c`和`bar`都属于`foo(..)`的作用域气泡，它们在`foo(..)`的外部都是不可访问的。也就是说，下面的代码会导致`ReferenceError`错误，因为这些标识符全局作用域是不可见的：

	bar(); // fails

	console.log( a, b, c ); // all 3 fail
	
但是，所有的标识符（`a`，`b`，`c`，`foo`以及`bar`）在`foo(..)`的内部都是可以访问的，同样在`bar(..)`的内部也是（假设在`bar(..)`的内部没有投影标识符声明）。

函数作用域意味着所有的变量都属于这个函数，并且可以在函数的所有地方被使用或重用（甚至在嵌套作用域中也能使用）。这种设计方式是非常有用的，并且可充分利用avaScript变量的“动态”特性来根据需要赋予不同类型的值。

另一方面，如果你不小心的采取预防措施，那么变量存在于整个作用域这件事会导致一些意想不到的陷阱。

## 隐藏在普通的作用域中

传统的对于函数的看法是你声明一个函数，然后在它的内部添加代码。但是反向思考同样是强大而有用的：获取你写的任意一段代码，在外部包装一个函数声明，这个做法会“隐藏”这段代码。

这样做产生的特殊结果是会围绕着这段代码创建一个作用域气泡，它意味着这段代码中的任何声明（变量或者函数）都会被附在这个新的包装函数的作用域中，而不是原有的那个外部的作用域。换句话说，你可以通过将变量和函数包裹在一个函数中来“隐藏”它们。

为什么“隐藏”变量和函数在技术上是有用的呢？

有各式各样的原因鼓励这种基于作用域的隐藏。它们往往来源于软件设计的“最小特权原则”[^note-leastprivilege]， 有时候也被称作“最小授权”或“最小暴露”原则。这一原则指出，在软件设计中，如模块/对象的API，你应该只暴露最少必需的内容，而将所有其他内容“隐藏”起来。

这一原则可以扩展到选择哪个作用域去包含变量和函数。如果所有的变量和函数都在全局作用域中，那么它们会显而易见的能被任何嵌套作用域访问。但是这就违反了“最小..”原则，在这个原则下你应该暴露一些变量和函数而将其他内容保持私有，因为在正确的代码使用上我们不建议访问这些私有的变量/函数。

例如：

	function doSomething(a) {
	    b = a + doSomethingElse( a * 2 );

	    console.log( b * 3 );
	}

	function doSomethingElse(a) {
	    return a - 1;
	}

	var b;

	doSomething( 2 ); // 15
	
在这段代码中，`b`变量以及`doSomethingElse(..)`函数就相当于`doSomething(..)`完成这个功能时的“私有”细节。允许外部作用域“访问”`b`和`doSomethingElse(..)`不仅是不必要的，而且也可能非常“危险”，在外部作用域中它们可能会被有意或者无意的以非期望的方式使用，并且这种调用可能会损害`doSomething(..)`的执行前的期望。

一个更“恰当”的设计应该是隐藏这些私有细节到`doSomething(..)`的作用域中，例如：

	function doSomething(a) {
	    function doSomethingElse(a) {
	        return a - 1;
	    }

	    var b;

	    b = a + doSomethingElse( a * 2 );

	    console.log( (b * 3) );
	}

	doSomething( 2 ); // 15
	
现在，`b`和`doSomethingElse(..)`都不受外部任何影响了，只会被`doSomething(..)`。它的函数内容和最终结果都没有变化，但是这种设计使得私有细节真正变得私有了，这种通常被认为是更好的软件结构。

## 回避冲突

另一个在作用域内“隐藏”变量和函数的好处是避免非预期的两个不同的同名不同用的标识符的冲突。冲突往往导致非预期的值的覆盖。

例如：

	function foo() {
	    function bar(a) {
	        i = 3; // changing the `i` in the enclosing scope's for-loop
	        console.log( a + i );
	    }

	    for (var i=0; i<10; i++) {
	        bar( i * 2 ); // oops, infinite loop ahead!
	    }
	}

	foo();
	
这里在`bar(..)`内部的赋值语句`i = 3`会非预期地覆盖`foo(..)`中所声明的`i`。在这个例子中，它会导致死循环，因为`i`被设置成一个固定的值`3`而永远都会保持 `< 10`。

`bar(..)`内部的赋值语句应该声明一个本地变量来使用，无论选择什么名称都可以。使用`var i = 3`即可修复这个问题（并且会为`i`创建一个“投影变量”）。另一个解决方案是选择一个完全另外的标识符名称，例如`var j = 3；`。但是你的软件在设计上可能更自然的想要使用同样的标识符名称，因此利用作用域来“隐藏”你的内部声明是你最好且唯一的选择。

## 全局“命名空间”

这里有一个特别明显的在全局作用域中变量冲突的例子。当你的程序加载了多个库时，如果你没有隐藏它们的内部/私有函数和变量，它们很可能会互相冲突。

这些库通常会在全局作用域上创建一个包含充分特殊名称的单一变量声明，通常是一个对象。这个对象被用作这个库的“命名空间”，而所有的特定需要暴露的方法内容都是这个对象（命名空间）的属性，而不是全局词法作用域上的标识符。

例如：

	var MyReallyCoolLibrary = {
	    awesome: "stuff",
	    doSomething: function() {
	        // ...
	    },
	    doAnotherThing: function() {
	        // ...
	    }
	};
	
## 模块管理

另一种避免代码冲突的选择是使用任何一种依赖管理工具来采取更加现代化的“模块”方式。通过使用这些工具，没有任何库会向全局作用域添加标识符，这些库被要求通过依赖管理工具的一些机制将它们的标识符显式地导入到另一个特定的作用域中。

应该注意到，这些工具并不会超脱作用域规则来使用“魔法”。它们只是使用了这里解释的作用域规则来确保没有标识符会被注入到任何共享的作用域中，并且相反地，它们会被放置在为私有的、不受冲突影响的作用域中，从而避免了任何意外的作用域冲突。

这样，你可以通过主动防御自己的代码来实现依赖管理工具的同样功能，而不需要真正使用这些工具，如果你真的选择使用该工具，那么可以到第5章看看模块模式。

## 函数作为作用域

我们已经知道可以截取任何代码片段并在外部包装一个函数，这种方式可以有效地对函数外部“隐藏”任何内部的变量或函数声明。

例如：

	var a = 2;

	function foo() { // <-- insert this

	    var a = 3;
	    console.log( a ); // 3

	} // <-- and this
	foo(); // <-- and this

	console.log( a ); // 2
	
尽管这种技术行之有效，但并不是非常理想。这种方式带来了一些缺点。第一个问题就是你必须要声明一个有名字的函数`foo()`，这意味着标识符`foo`自身也“污染”了外部作用域（这里是全局作用域）。并且我们需要显示地用名称调用函数（`foo`）来使内部的代码真正执行。

如果函数不需要一个名称（或者，名称不会污染外部作用域），并且函数可以被自动执行，就非常理想了。

幸运的是，JavaScript提供了一个处理这两题的解决方案。

	var a = 2;

	(function foo(){ // <-- insert this

	    var a = 3;
	    console.log( a ); // 3

	})(); // <-- and this

	console.log( a ); // 2
	
让我们分解一下这里发生的事情。

首先，请注意包装函数语句以`(function..`开始，区别于普通的`function..`。尽管这里看起来只是一点点细节，但实际上却是一个很大的变化。不同于将函数视为一个标准的声明，这里的函数被视为一个函数表达式。

**注：**最简单的区分函数声明与函数表达式的方式是查看单词“function”在语句中的位置。（不仅仅只是一行，而是一个完整的语句。）如果“function”是语句的第一个单词，那么就是一个函数声明。否则，就是一个函数表达式。

这里我们能看到的函数声明与函数表达式之间的关键区别在于它的名称在哪里被绑定为一个标识符。

比较一下这两段代码。在第一段代码中，名称`foo`被绑定到外部作用域，并且我们直接通过`foo()`调用它。在第二段代码中，名称`foo`并没有和外部作用域绑定，而只和自己的函数内部绑定。

换句话说，`(function foo(){ .. })`作为一个表达式意味着标识符`foo`只在`..`所表示的地方存在，而不在外部的作用域中。将名字`foo`隐藏在内部意味着它不会给外部作用域带来不必要的污染。

## 匿名 vs 命名

你可能已经很复习将函数表达式作为回调参数了，例如：

	setTimeout( function(){
	    console.log("I waited 1 second!");
	}, 1000 );
	
这种被叫做“匿名函数表达式”，因为`function()...`之上没有标识符。函数表达式可以是匿名的，但是函数声明却不能忽略名字 -- 那样会造成非法的JS语法。

匿名函数表达式编写非常快速和便捷，并且许多库和工具都倾向于鼓励这种代码风格。但是，这里有一些缺点是需要考虑的：

1. 匿名函数在堆栈跟踪时没有可用的名字，这使得debug它们变得更加困难。

2. 当函数没有名字时，如果它要调用自己进行递归等等，**被弃用的**`arguments.callee`方法会不得不被使用。另一个需要引用自身的例子是当一个事件处理函数想要在触发事件后将自己解绑时。

3. 匿名函数所缺失的名称往往是被用来提供更易于阅读/理解的代码。一个描述性的名字有助于有疑问的代码将自身文档化。

**内链函数表达式**是强大而有用的 -- 匿名函数与命名函数之争ing没有削减这一点。为函数提供一个名字可以非常有效的处理所有这些问题，而不带来其他缺点。因此，最佳实践是总是将你的函数表达式命名：

	setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
	    console.log( "I waited 1 second!" );
	}, 1000 );
	
## 立即调用函数表达式

	var a = 2;

	(function foo(){

	    var a = 3;
	    console.log( a ); // 3

	})();

	console.log( a ); // 2
	
现在我们就通过将函数包裹在`()`对的方式拥有了一个函数表达式，我们可以通过在尾部添加另一对`()`来执行这个函数，就像`(function foo(){ .. })()`。第一个外部的`( )`对使得函数变成了一个表达式，而第二对`( )`执行这一函数。

这个模式实在是太普遍了，几年之前委员会同意给他赋予一个术语： **IIFE**，它表示**I**mmediately **I**nvoked **F**unction **E**xpression。

当然，IIFE不需要名字 -- 最常见的IIFE格式是使用一个匿名函数表达式。稍微不常见的做法是将IIFE命名，命名IIFE比起匿名函数表达式具有前面所讲述的所有好处，因此这是一种好的实践方式。

	var a = 2;

	(function IIFE(){

	    var a = 3;
	    console.log( a ); // 3

	})();

	console.log( a ); // 2
	
这里有一段和传统IIFE轻微的区别，有的人会喜欢使用`(function(){ .. })`。仔细看看它们的不同。在第一种模式里，函数表达式被包装在`( )`内，然后负责调用的`()`对处在它外部。在第二种模式里，负责调用的`()`对被移动到包装`()`对的内部。

这两种形式在功能上是相同的，**值纯粹取决于你喜欢哪种风格。**

另一种IIFE的变种是非常常见的，它们仅仅是函数调用，并传入参数。

例如：

	var a = 2;

	(function IIFE( global ){

	    var a = 3;
	    console.log( a ); // 3
	    console.log( global.a ); // 2

	})( window );

	console.log( a ); // 2
	
我们将`window`对象传进函数，但我们将其命名为`global`参数，因此我们会对全局和非全局的引用有一个明确的风格。当然，你可以向函数内传进外部作用域的任何东西，并且你可以将其命名为任何适合你的参数。这仅仅是风格上的选择。

另一种这种模式的应用是用来处理一些质疑，默认的`undefined`标识符的值可能会被不正确的覆盖，从而导致不可预知的结果。通过将一个参数命名为`undefined`而不向它传递任何值，我们可以确定`undefined`标识符的实际值是undefined。如下面代码所示：

	undefined = true; // setting a land-mine for other code! avoid!

	(function IIFE( undefined ){

	    var a;
	    if (a === undefined) {
	        console.log( "Undefined is safe here!" );
	    }

	})();

还有另一种IIFE是用来翻转实物的顺序，这里被用来执行的函数是放在第二位，在调用语句和参数之后。这种模式被用在UMD（Universal Module Definition）项目中。有些人觉得这理解起来更容易了，虽然它有点冗长。

	var a = 2;

	(function IIFE( def ){
	    def( window );
	})(function def( global ){

	    var a = 3;
	    console.log( a ); // 3
	    console.log( global.a ); // 2

	});
	
这里`def`函数表达式在这段代码的第二部分才定义定义，然后作为参数（也被称为`def`）传递到第一部分定义的`IIFE`函数中。最后，参数`def`（函数）被调用，将`windows`作为`global`参数传入进去。

## 代码块作为作用域

尽管函数是最通用的作用域单元，并且是JS范围中最广为流传的设计方案，但是也存在一些其他的作用域单元，使用这些作用域单元可以是你写出更好、更清晰也更容易维护的代码。

很多JavaScript以外的语言支持块作用域，因此很多从其他语言而来的开发者都对此已经烂熟于心，然而那些只在JavaScript中工作过的开发者会觉得这个概念有一点生疏。

但是即使你从未通过块级作用域的方式编写过任何一行代码，你仍然对于这种JavaScript中非常普遍的惯用方式非常熟悉。

	for (var i=0; i<10; i++) {
	    console.log( i );
	}

我们在for循环头中声明变量`i`，主要是因为我们的意图是只在这个for循环的上下文中使用这个`i`，而实际上我们忽略了这个变量实际上将自己放在了外部作用域（函数作用域或全局作用域）中的事实。

这也就是所谓的块作用域。尽可能靠近变量要使用的地方声明变量。另一个例子是：

	var foo = true;
	
	if (foo) {
	    var bar = foo * 2;
	    bar = something( bar );
	    console.log( bar );
	}

我们只在if语句的上下文中使用了`bar`变量，因此这看起来说明我们应该在if块中声明它。但是我们声明变量的地方和什么时候使用`var`是无关的，因为它们总是属于外部的作用域。这段代码实际上只是个“假”块级作用域，完全处于代码风格的原因，我们只能依靠自觉不去在另一处意料之外地使用`bar`。

块级作用域是一个用来扩展之前所说的“最小权限原则”，和之前的在函数中隐藏信息相比，它在我们的代码块中隐藏了信息。

再次考虑一下这个for循环的例子：

	for (var i=0; i<10; i++) {
	    console.log( i );
	}
	
为什么要用只会（或者说只应该）在for循环中使用的变量`i`污染整个作用域呢？

但更重要的是，开发人员可能倾向于自己检查是否意外地在原本意图之外（重新）使用了变量，它们希望在这种情况下被告知一个未知变量的错误。块级作用域（如果有的话），可以使i仅仅在for循环中可用，如果在函数的其他地方使用则会导致一个错误。这样有助于确保变量不被以令人困惑或难以维护的方式重用。

但是，令人悲伤的事实就是，目前看来，JavaScript没有块级作用域的机制。

## `with`

我们在第2章学习了`with`。尽管这是一个让人讨厌的结构，但是它能够实现（一种）块级作用域，在`with`中由对象所创建的作用域只存在于with语句的生命周期内，而不存在于整个外部作用域中。

## `try/catch`

有一个非常鲜为人知的事实是，JavaScript在ES3中指定了在`try/catch`的`catch`分句中声明的变量是`catch`块的块级作用域。

例如：

	try {
	    undefined(); // illegal operation to force an exception!
	}
	catch (err) {
	    console.log( err ); // works!
	}

	console.log( err ); // ReferenceError: `err` not found

可以看出，`err`只在`catch`分句中存在，当你在其他地方引用它时会抛出一个错误。


**注：**尽管这种行为已经被标准指定并且几乎所有标准JS环境（可能之后老版本的IE除外）都成立，但许多代码检查工具仍然在抱怨当你在一个作用域中有有两个或更多`catch`分句而每个分句都声明了相同标识符的名称的场景。这种场景实际上并不是一种重定义，因为变量都安全地被包裹在块作用域中，但是代码检查工具似乎仍然在吵吵不休地抱怨这一种用法。

为了避免这种不必要的警告，有些开发者会选择将他们的`catch`变量命名为`err1`，`err2`等等。而其他的开发者会简单地关掉对于重复变量名的检验。

`catch`的块级作用域天然特性似乎只是一个没什么用的理论事实，但是你可以在附录B中看到它是多么的有用。

## `let`

到目前为止，我们已经知道JavaScript只对一些奇怪的小众行为上暴露块作用域功能。如果仅仅是这样的话，那么在许多年内块作用域对JavaScript开发者来说都没什么用。

幸运的是，ES6改变了这一切，它带来了一个新的关键词`let`，它和`var`平起平坐成为第二种声明变量的方式。

`let`关键词将变量声明附在它最近的块（一般是一个`{ .. }`对）的作用域中。换句话说，`let`隐式地为它声明的变量劫持了任何块的作用域。

	var foo = true;

	if (foo) {
	    let bar = foo * 2;
	    bar = something( bar );
	    console.log( bar );
	}

	console.log( bar ); // ReferenceError
	
使用`let`来将一个变量附着在一个已经存在的块上是隐式完成的。如果你没有在编写代码的过程中密切地关注变量到底附着在哪个作用域上、并且总是移动代码块、将代码块包装在其他块的内部，那么它会让你感到疑惑。

明确地为块作用域创建代码块可以处理这些问题，使得变量附着在哪里这件事变得明显。通常，显式的代码总是比隐式或者细微的代码要更好。这种显式创建块作用域的风格很容易实现，并且和其他语言中的块作用域工作的方式类似。

	var foo = true;

	if (foo) {
	    { // <-- explicit block
	        let bar = foo * 2;
	        bar = something( bar );
	        console.log( bar );
	    }
	}

	console.log( bar ); // ReferenceError
	
我们可以通过简单地在任何一个有效语法的位置引入一个`{ .. }`对来为`let`强制创建一个用来绑定的块。在上面的例子中，我们已经在if语句中显式地创建了一个块，在之后的重构中，我们可以简单地移动这个块而不会影响到外部if语句的位置和语义。

**注：**另一个显式创建块级作用域的例子，请见附录B

在第四章中，我们会谈到变量提升，它描述的是变量声明被提升到它发生的整个作用域中。

但是，通过`let`声明的变量不会被提升到它们所在的整个块级作用域中。这种声明直到声明语句在代码块“存在”的那一刻才真正发生。

	{
	   console.log( bar ); // ReferenceError!
	   let bar = 2;
	}
	
## 垃圾回收

另一个块级作用域是有用的的另一个原因和闭包以及垃圾回收有关。我们在这里做简要说明，但是闭包的机制直到第5章才会解释。

考虑下面的代码：

	function process(data) {
	    // do something interesting
	}

	var someReallyBigData = { .. };

	process( someReallyBigData );

	var btn = document.getElementById( "my_button" );

	btn.addEventListener( "click", function click(evt){
	    console.log("button clicked");
	}, /*capturingPhase=*/false );
	
这里，`click`函数的回调函数并不需要`someReallyBigData`。这意味着，从理论上说，在`process(..)`运行之后，这段非常占用内存的数据结构可以被回收掉。但是很有可能（取决于实现方式）JS引擎仍然将保存这段内容，因为`click`函数拥有一个在整个作用域之上的闭包。

块级作用域可以处理这种问题，能够通知引擎它不需要一直持有`someReallyBigData`：

	function process(data) {
	    // do something interesting
	}

	// anything declared inside this block can go away after!
	{
	    let someReallyBigData = { .. };

	    process( someReallyBigData );
	}

	var btn = document.getElementById( "my_button" );

	btn.addEventListener( "click", function click(evt){
	    console.log("button clicked");
	}, /*capturingPhase=*/false );
	
为变量显示地声明可以被绑定的代码块是一种有效的手段，你可以经常使用它。

## `let`循环

我们之前讨论的例子中有一个特殊的使用`let`的例子。

	for (let i=0; i<10; i++) {
	    console.log( i );
	}

	console.log( i ); // ReferenceError

for循环头中的`let`不仅仅将`i`绑定到for循环体内，事实上，它将`i`**重新绑定**到每个循环迭代中，确保在上次循环迭代结束后重新给它赋值。

这里是另一个说明这种行为的例子：

	{
	    let j;
	    for (j=0; j<10; j++) {
	        let i = j; // re-bound for each iteration!
	        console.log( i );
	    }
	}

我们会在第5章讨论闭包时阐明这种有趣行为的原因。

因为`let`声明的变量可以附着到任意块中，而不需要到整个函数作用域（或全局作用域），但是如果已有的代码存在对函数作用域的`var`声明的隐式依赖，那么这里就会有陷阱，当你在尝试用`let`代替`var`时需要小心处理。

考虑下面的代码：

	var foo = true, baz = 10;

	if (foo) {
	    var bar = 3;

	    if (baz > bar) {
	        console.log( baz );
	    }

	    // ...
	}
	
这段代码可以很容易的被重构成：

	var foo = true, baz = 10;

	if (foo) {
	    var bar = 3;

	    // ...
	}

	if (baz > bar) {
	    console.log( baz );
	}
	
但是，当你在使用块级作用域时就要小心了：

	var foo = true, baz = 10;

	if (foo) {
	    let bar = 3;

	    if (baz > bar) { // <-- don't forget `bar` when moving!
	        console.log( baz );
	    }
	}

你可以在附录B中找到另一种（更加显式）的块级作用域风格，它可以使得维护/重构代码更简单。

## `const`

除了`let`以外，ES6还引入了`const`，它同样创建一个块级作用域，但是这些值是不可变的（常量）。任何尝试对它进行修改的操作会导致一个错误。

	var foo = true;

	if (foo) {
	    var a = 2;
	    const b = 3; // block-scoped to the containing `if`

	    a = 3; // just fine!
	    b = 4; // error!
	}

	console.log( a ); // 3
	console.log( b ); // ReferenceError!
	
# 章节回顾（给太长不看的人看的）

函数是JavaScript中最常见的作用域。在一个函数内部所声明的变量和函数实际上对外部的作用域来说是“隐藏”的，这是好的软件设计准则。

但是函数不是唯一的作用域单元。块级作用域指的是变量和函数可以属于任何一个代码块（一般来说，是`{ .. }`括号对），而不仅仅属于外部函数。

从ES3开始，`try/catch`结构在`catch`分支中有了块级作用域。

在ES6中，`let`关键词（一个`var`关键词的表亲）被引入来允许在任何代码块中声明变量。代码`if(..) { let a = 3; }`会声明一个`a`变量来实际上劫持`if`的 `{ .. }`块级作用域，并将自身附着在上面。

尽管有人这样认为，块级作用域不应被视为`var`函数作用域的完全替代品。这两种特性都应该存在，开发者应该基于如何创建更好、更容易阅读/维护的代码的角度来选择性的使用这两种技术。