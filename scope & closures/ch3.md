# 你不懂JS：作用域和闭包

# 第三章：函数和块作用域

我们在第二种了解到，作用域由一系列的像容器的“气泡”组成，内部会定义标识符（变量，函数）。这些气泡整齐地嵌套在一起，并且这个嵌套关系是在编写时定义的。

但是怎样才能创建一个新的气泡？只能通过函数吗？JavaScript中友其他的结构来创建作用域气泡吗？

## 来源于函数的作用域

这些问题的最普遍答案是JavaScript具有基于函数的作用域。也就是说，你所声明的每个函数都会为它自己创建一个气泡，其他任何结构都无法创建它们自己的作用域气泡。我们会在之后看到，这并不是那么准确。

但是首先，让我们探索一下函数作用域以及它的含义。

考虑如下代码：

	function foo(a) {
	    var b = 2;

	    // some code

	    function bar() {
	        // ...
	    }

	    // more code

	    var c = 3;
	}
	
在这段代码中，`foo(..)`的作用域气泡包含了标识符`a`，`b`，`c`以及`bar`。它和变量声明出现的位置**没有关系**，无论声明在何处出现，变量或函数都属于该作用域气泡。我们在下一章会探讨一下这究竟是如何实现的。

`bar(..)`拥有自己的作用域气泡。全局作用域也是，它只有一个附在它之上的标识符：`foo`。

因为`a`，`b`，`c`和`bar`都属于`foo(..)`的作用域气泡，它们在`foo(..)`的外部都是不可访问的。也就是说，下面的代码会导致`ReferenceError`错误，因为这些标识符全局作用域是不可见的：

	bar(); // fails

	console.log( a, b, c ); // all 3 fail
	
但是，所有的标识符（`a`，`b`，`c`，`foo`以及`bar`）在`foo(..)`的内部都是可以访问的，同样在`bar(..)`的内部也是（假设在`bar(..)`的内部没有投影标识符声明）。

函数作用域意味着所有的变量都属于这个函数，并且可以在函数的所有地方被使用或重用（甚至在嵌套作用域中也能使用）。这种设计方式是非常有用的，并且可充分利用avaScript变量的“动态”特性来根据需要赋予不同类型的值。

另一方面，如果你不小心的采取预防措施，那么变量存在于整个作用域这件事会导致一些意想不到的陷阱。

## 隐藏在普通的作用域中

传统的对于函数的看法是你声明一个函数，然后在它的内部添加代码。但是反向思考同样是强大而有用的：获取你写的任意一段代码，在外部包装一个函数声明，这个做法会“隐藏”这段代码。

这样做产生的特殊结果是会围绕着这段代码创建一个作用域气泡，它意味着这段代码中的任何声明（变量或者函数）都会被附在这个新的包装函数的作用域中，而不是原有的那个外部的作用域。换句话说，你可以通过将变量和函数包裹在一个函数中来“隐藏”它们。

为什么“隐藏”变量和函数在技术上是有用的呢？

有各式各样的原因鼓励这种基于作用域的隐藏。它们往往来源于软件设计的“最小特权原则”[^note-leastprivilege]， 有时候也被称作“最小授权”或“最小暴露”原则。这一原则指出，在软件设计中，如模块/对象的API，你应该只暴露最少必需的内容，而将所有其他内容“隐藏”起来。

这一原则可以扩展到选择哪个作用域去包含变量和函数。如果所有的变量和函数都在全局作用域中，那么它们会显而易见的能被任何嵌套作用域访问。但是这就违反了“最小..”原则，在这个原则下你应该暴露一些变量和函数而将其他内容保持私有，因为在正确的代码使用上我们不建议访问这些私有的变量/函数。

例如：

	function doSomething(a) {
	    b = a + doSomethingElse( a * 2 );

	    console.log( b * 3 );
	}

	function doSomethingElse(a) {
	    return a - 1;
	}

	var b;

	doSomething( 2 ); // 15
	
在这段代码中，`b`变量以及`doSomethingElse(..)`函数就相当于`doSomething(..)`完成这个功能时的“私有”细节。允许外部作用域“访问”`b`和`doSomethingElse(..)`不仅是不必要的，而且也可能非常“危险”，在外部作用域中它们可能会被有意或者无意的以非期望的方式使用，并且这种调用可能会损害`doSomething(..)`的执行前的期望。

一个更“恰当”的设计应该是隐藏这些私有细节到`doSomething(..)`的作用域中，例如：

	function doSomething(a) {
	    function doSomethingElse(a) {
	        return a - 1;
	    }

	    var b;

	    b = a + doSomethingElse( a * 2 );

	    console.log( (b * 3) );
	}

	doSomething( 2 ); // 15
	
现在，`b`和`doSomethingElse(..)`都不受外部任何影响了，只会被`doSomething(..)`。它的函数内容和最终结果都没有变化，但是这种设计使得私有细节真正变得私有了，这种通常被认为是更好的软件结构。

## 回避冲突

另一个在作用域内“隐藏”变量和函数的好处是避免非预期的两个不同的同名不同用的标识符的冲突。冲突往往导致非预期的值的覆盖。

例如：

	function foo() {
	    function bar(a) {
	        i = 3; // changing the `i` in the enclosing scope's for-loop
	        console.log( a + i );
	    }

	    for (var i=0; i<10; i++) {
	        bar( i * 2 ); // oops, infinite loop ahead!
	    }
	}

	foo();
	
这里在`bar(..)`内部的赋值语句`i = 3`会非预期地覆盖`foo(..)`中所声明的`i`。在这个例子中，它会导致死循环，因为`i`被设置成一个固定的值`3`而永远都会保持 `< 10`。

`bar(..)`内部的赋值语句应该声明一个本地变量来使用，无论选择什么名称都可以。使用`var i = 3`即可修复这个问题（并且会为`i`创建一个“投影变量”）。另一个解决方案是选择一个完全另外的标识符名称，例如`var j = 3；`。但是你的软件在设计上可能更自然的想要使用同样的标识符名称，因此利用作用域来“隐藏”你的内部声明是你最好且唯一的选择。

## 全局“命名空间”

这里有一个特别明显的在全局作用域中变量冲突的例子。当你的程序加载了多个库时，如果你没有隐藏它们的内部/私有函数和变量，它们很可能会互相冲突。

这些库通常会在全局作用域上创建一个包含充分特殊名称的单一变量声明，通常是一个对象。这个对象被用作这个库的“命名空间”，而所有的特定需要暴露的方法内容都是这个对象（命名空间）的属性，而不是全局词法作用域上的标识符。

例如：

	var MyReallyCoolLibrary = {
	    awesome: "stuff",
	    doSomething: function() {
	        // ...
	    },
	    doAnotherThing: function() {
	        // ...
	    }
	};
	
## 模块管理

另一种避免代码冲突的选择是使用任何一种依赖管理工具来采取更加现代化的“模块”方式。通过使用这些工具，没有任何库会向全局作用域添加标识符，这些库被要求通过依赖管理工具的一些机制将它们的标识符显式地导入到另一个特定的作用域中。

应该注意到，这些工具并不会超脱作用域规则来使用“魔法”。它们只是使用了这里解释的作用域规则来确保没有标识符会被注入到任何共享的作用域中，并且相反地，它们会被放置在为私有的、不受冲突影响的作用域中，从而避免了任何意外的作用域冲突。

这样，你可以通过主动防御自己的代码来实现依赖管理工具的同样功能，而不需要真正使用这些工具，如果你真的选择使用该工具，那么可以到第5章看看模块模式。

## 函数作为作用域

我们已经知道可以截取任何代码片段并在外部包装一个函数，这种方式可以有效地对函数外部“隐藏”任何内部的变量或函数声明。

例如：

	var a = 2;

	function foo() { // <-- insert this

	    var a = 3;
	    console.log( a ); // 3

	} // <-- and this
	foo(); // <-- and this

	console.log( a ); // 2
	
尽管这种技术行之有效，但并不是非常理想。这种方式带来了一些缺点。第一个问题就是你必须要声明一个有名字的函数`foo()`，这意味着标识符`foo`自身也“污染”了外部作用域（这里是全局作用域）。并且我们需要显示地用名称调用函数（`foo`）来使内部的代码真正执行。

如果函数不需要一个名称（或者，名称不会污染外部作用域），并且函数可以被自动执行，就非常理想了。

幸运的是，JavaScript提供了一个处理这两题的解决方案。

	var a = 2;

	(function foo(){ // <-- insert this

	    var a = 3;
	    console.log( a ); // 3

	})(); // <-- and this

	console.log( a ); // 2
	
让我们分解一下这里发生的事情。

首先，请注意包装函数语句以`(function..`开始，区别于普通的`function..`。尽管这里看起来只是一点点细节，但实际上却是一个很大的变化。不同于将函数视为一个标准的声明，这里的函数被视为一个函数表达式。

**注：**最简单的区分函数声明与函数表达式的方式是查看单词“function”在语句中的位置。（不仅仅只是一行，而是一个完整的语句。）如果“function”是语句的第一个单词，那么就是一个函数声明。否则，就是一个函数表达式。

这里我们能看到的函数声明与函数表达式之间的关键区别在于它的名称在哪里被绑定为一个标识符。

比较一下这两段代码。在第一段代码中，名称`foo`被绑定到外部作用域，并且我们直接通过`foo()`调用它。在第二段代码中，名称`foo`并没有和外部作用域绑定，而只和自己的函数内部绑定。

换句话说，`(function foo(){ .. })`作为一个表达式意味着标识符`foo`只在`..`所表示的地方存在，而不在外部的作用域中。将名字`foo`隐藏在内部意味着它不会给外部作用域带来不必要的污染。

## 匿名 vs 命名

你可能已经很复习将函数表达式作为回调参数了，例如：

	setTimeout( function(){
	    console.log("I waited 1 second!");
	}, 1000 );
	
这种被叫做“匿名函数表达式”，因为`function()...`之上没有标识符。函数表达式可以是匿名的，但是函数声明却不能忽略名字 -- 那样会造成非法的JS语法。

匿名函数表达式编写非常快速和便捷，并且许多库和工具都倾向于鼓励这种代码风格。但是，这里有一些缺点是需要考虑的：

1. 匿名函数在堆栈跟踪时没有可用的名字，这使得debug它们变得更加困难。

2. 当函数没有名字时，如果它要调用自己进行递归等等，**被弃用的**`arguments.callee`方法会不得不被使用。另一个需要引用自身的例子是当一个事件处理函数想要在触发事件后将自己解绑时。

3. 匿名函数所缺失的名称往往是被用来提供更易于阅读/理解的代码。一个描述性的名字有助于有疑问的代码将自身文档化。

**内链函数表达式**是强大而有用的 -- 匿名函数与命名函数之争ing没有削减这一点。为函数提供一个名字可以非常有效的处理所有这些问题，而不带来其他缺点。因此，最佳实践是总是将你的函数表达式命名：

	setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
	    console.log( "I waited 1 second!" );
	}, 1000 );
	
## 立即调用函数表达式

	var a = 2;

	(function foo(){

	    var a = 3;
	    console.log( a ); // 3

	})();

	console.log( a ); // 2
	
现在我们就通过将函数包裹在`()`对的方式拥有了一个函数表达式，我们可以通过在尾部添加另一对`()`来执行这个函数，就像`(function foo(){ .. })()`。第一个外部的`( )`对使得函数变成了一个表达式，而第二对`( )`执行这一函数。

这个模式实在是太普遍了，几年之前委员会同意给他赋予一个术语： **IIFE**，它表示**I**mmediately **I**nvoked **F**unction **E**xpression。

当然，IIFE不需要名字 -- 最常见的IIFE格式是使用一个匿名函数表达式。稍微不常见的做法是将IIFE命名，命名IIFE比起匿名函数表达式具有前面所讲述的所有好处，因此这是一种好的实践方式。

	var a = 2;

	(function IIFE(){

	    var a = 3;
	    console.log( a ); // 3

	})();

	console.log( a ); // 2
	
这里有一段和传统IIFE轻微的区别，有的人会喜欢使用`(function(){ .. })`。仔细看看它们的不同。在第一种模式里，函数表达式被包装在`( )`内，然后负责调用的`()`对处在它外部。在第二种模式里，负责调用的`()`对被移动到包装`()`对的内部。

这两种形式在功能上是相同的，**值纯粹取决于你喜欢哪种风格。**

另一种IIFE的变种是非常常见的，它们仅仅是函数调用，并传入参数。

例如：

	var a = 2;

	(function IIFE( global ){

	    var a = 3;
	    console.log( a ); // 3
	    console.log( global.a ); // 2

	})( window );

	console.log( a ); // 2
	
我们将`window`对象传进函数，但我们将其命名为`global`参数，因此我们会对全局和非全局的引用有一个明确的风格。当然，你可以向函数内传进外部作用域的任何东西，并且你可以将其命名为任何适合你的参数。这仅仅是风格上的选择。

另一种这种模式的应用是用来处理一些质疑，默认的`undefined`标识符的值可能会被不正确的覆盖，从而导致不可预知的结果。通过将一个参数命名为`undefined`而不向它传递任何值，我们可以确定`undefined`标识符的实际值是undefined。如下面代码所示：

	undefined = true; // setting a land-mine for other code! avoid!

	(function IIFE( undefined ){

	    var a;
	    if (a === undefined) {
	        console.log( "Undefined is safe here!" );
	    }

	})();

还有另一种IIFE是用来翻转实物的顺序，这里被用来执行的函数是放在第二位，在调用语句和参数之后。这种模式被用在UMD（Universal Module Definition）项目中。有些人觉得这理解起来更容易了，虽然它有点冗长。

	var a = 2;

	(function IIFE( def ){
	    def( window );
	})(function def( global ){

	    var a = 3;
	    console.log( a ); // 3
	    console.log( global.a ); // 2

	});
	
这里`def`函数表达式在这段代码的第二部分才定义定义，然后作为参数（也被称为`def`）传递到第一部分定义的`IIFE`函数中。最后，参数`def`（函数）被调用，将`windows`作为`global`参数传入进去。

## 代码块作为作用域

尽管函数是最通用的作用域单元，并且是JS范围中最广为流传的设计方案，但是也存在一些其他的作用域单元，使用这些作用域单元可以是你写出更好、更清晰也更容易维护的代码。

很多JavaScript以外的语言支持块作用域，因此很多从其他语言而来的开发者都对此已经烂熟于心，然而那些只在JavaScript中工作过的开发者会觉得这个概念有一点生疏。

但是即使你从未通过块级作用域的方式编写过任何一行代码，你仍然对于这种JavaScript中非常普遍的惯用方式非常熟悉。

	for (var i=0; i<10; i++) {
	    console.log( i );
	}

我们在for循环头中声明变量`i`，主要是因为我们的意图是只在这个for循环的上下文中使用这个`i`，而实际上我们忽略了这个变量实际上将自己放在了外部作用域（函数作用域或全局作用域）中的事实。

这也就是所谓的块作用域。尽可能靠近变量要使用的地方声明变量。另一个例子是：

	var foo = true;
	
	if (foo) {
	    var bar = foo * 2;
	    bar = something( bar );
	    console.log( bar );
	}

