# 你不懂JS：作用域和闭包

# 第五章：作用域闭包

在我们在讲述这一之前，希望你已经对作用域的作用机制有了清晰牢固的理解。

我们下面把注意力放到一个非常重要但难以捉摸的部分上：**闭包**。如果你一直跟随我们讨论了词法作用域，那么你所得到的好处就是理解起闭包来会非常简单。有一个男人在巫师的门帘之后，我们马上就会见到他。不，他的名字不是Crockford！（Douglas Crockford）

如果你对于词法作用域还有任何问题，在继续看下去之前，你应该趁这个机会回顾一下第二章。

## 启示

对于那些已经在JavaScript中有多年经验，但可能从未完全找过闭包的概念的人来说，了解闭包可能看起来就像是一种涅磐，必须通过努力和牺牲才能实现。

我回想起多年前我对于JavaScript有一个清楚的认知，但是完全不了解到底闭包是什么。有一种暗示一直在戏弄和嘲笑着我，它预示着这门语言还有另一面，了解它之后我能够获得比现在已知的更多的能力。我记得我通读了早期框架的源代码，尝试去理解它究竟是如何工作的。我记得第一次“模块化”的某些概念在我脑海中浮现时的场景。我清楚地记得那个“啊哈！”的瞬间。

当年我没有弄清楚的东西，花费了数年时间来理解的东西，现在我希望向你透露的秘密，是这个：**在JavaScript中，闭包无处不在，你只是需要认识它并拥抱它。**闭包不是一个你必须学习新的语法或模式才能够理解的东西。闭包甚至不是一种你必须掌握的武器，不像卢克掌控原力一样必须掌握。

闭包是编写代码而产生的，它依赖于词法作用域。它仅仅是产生。你不需要刻意地创建一个闭包来利用它的能力。闭包在你代码中无处不在地被创建并且被使用。你所缺失的，是适当的上下文来认识、拥抱并亲自使用闭包。

这个启示的时刻应该是：**噢，闭包已经在我代码中无处不在了，我终于可以看到它们了。**理解闭包就像尼奥第一次看见母体一样。

## 一些细节

好的，夸张而无耻的电影引用已经够了。

这里有一个你所需要的很接地气的定义来理解并认识闭包：

	闭包是一个函数可以在其词法作用域外执行时，仍然记住并访问它的词法作用域的能力。

让我们看看代码来说明这个定义。

	function foo() {
	    var a = 2;

	    function bar() {
	        console.log( a ); // 2
	    }

	    bar();
	}

	foo();

这段代码和我们之前讨论的嵌套作用域类似。函数`bar()`基于词法作用域的查询规则（这里是一个RHS查询）访问了外部闭包的变量`a`。

这是一个“闭包”吗？

呃，从技术层面上说... 可能是。但是从我们那个接地气的定义上看：并不完全是这样。我认为最准确的解释`bar()`引用`a`的方式是通过词法作用域查询规则来解释，这些规则只是闭包的一部分（请注意这里！）。

从纯学术的角度来看，上面这段代码所描述的是函数`bar()`拥有一个在`foo()`作用域之上的闭包（事实上，这个闭包也包括了它所访问到的作用域的其他部分，在我们这个例子中，也包括全局作用域）。略有不同的是，`bar()`在`foo()`的作用域之上。为什么？因为`bar`在`foo()`的内部出现。很简单吧。

但是，用这种方式定义的闭包并不是完全可见的，我们也没有在这段代码中看到闭包的使用。我们只是清楚的看到了词法作用域，但是闭包仍然处在代码神秘面纱的背后。

让我们用下面这段代码给闭包打一个全景光：

	function foo() {
	    var a = 2;

	    function bar() {
	        console.log( a );
	    }

	    return bar;
	}

	var baz = foo();

	baz(); // 2 -- Whoa, closure was just observed, man.
	
函数`bar()`可以访问`foo()`内部的作用域。但是然后，我们获取`bar()`，函数自身，并将它作为一个值传递。在这里我们`return`这个`bar`引用的函数对象自身。

在执行`foo()`之后，我们将它的返回值（内部的`bar`函数）赋值给名为`baz`的便利，然后我们调用`bar()`的时候，实际上是调用了我们的内部函数`bar()`，只是通过另一个不同的标识符而已。

`bar()`被执行了，当然。但是在这个例子中，它是在它所定义的词法作用域的外部被执行的。

在`foo()`执行之后，我们普遍会认为整个`foo()`的内部作用域将会消失，因为我们知道引擎有一个垃圾回收器来回收不需要了的内存。因为`foo()`的内容不再被使用了，因此它们看起来很自然地应该被回收掉。

但是闭包的“神奇”之处在于，它阻止了这一切的发生。内部的作用域实际上仍然在“被使用”，因此不会被回收。谁在使用它？**函数`bar()`自身。**

拜其声明地点所赐，`bar()`在`foo()`的内部作用域上拥有一个词法作用域的闭包，它为`bar()`保存着这个作用域以便之后需要使用。

**`bar()`仍然拥有一个对该作用域的引用，这个引用被称为闭包。**

因此，几微秒之后，当变量`baz`被调用（实际是我们在内部声明的`bar`函数被调用）时，`bar()`就能够访问它在编写时所带有的词法作用域，因此它能够像我们期望的一样访问变量`a`。

函数在其自身定义的词法作用域外可以被调用，这归功于**闭包**允许函数可以继续访问编写时所定义的词法作用域。

当然，有很多种函数作为值被传递，然后再另一个地方调用的例子。它们都可以用闭包来解释。

	function foo() {
	    var a = 2;

	    function baz() {
	        console.log( a ); // 2
	    }

	    bar( baz );
	}

	function bar(fn) {
	    fn(); // look ma, I saw closure!
	}
	
我们将内部函数`baz`传递给`bar`，并且调用该内部函数（现在名为`fn`），当我们这样做时，我们可以看到它在在`foo()`作用域内部的闭包，因为它可以访问到`a`。

这些传递的函数也可以是非直接的。

	var fn;

	function foo() {
	    var a = 2;

	    function baz() {
	        console.log( a );
	    }

	    fn = baz; // assign `baz` to global variable
	}

	function bar() {
	    fn(); // look ma, I saw closure!
	}

	foo();

	bar(); // 2
	
无论我们采用什么方式将内部的函数传递到它的词法作用域之外，它都会仍然保留它对它原始声明处的作用域的引用，并且无论我们在什么地方执行它，闭包都会被使用到。

## 现在我能看见了

